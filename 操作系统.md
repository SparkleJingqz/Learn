# 0.前置概念

## 0.1 中断&异常

- 中断机制 -> **操作系统介入,管理**(用户态->核心态 处理中断信号) -> 实现多道程序并发执行
  1. 中断发生时 - CPU立即进入核心态,当前进程暂停运行,由操作系统内核对中断进行处理
  2. 不同中断信号进行不同处理
- 用户态与核心之间的转换
  - **用户态->核心态 : 唯一途径 - 中断**
  - 核心态->用户态: 执行特权指令,将程序状态字PSW标志位设置为用户态
- 分类
  - 内中断(异常,例外,陷入) - 信号来源于CPU内部,有关于当前执行指令
    - 自愿中断(陷入指令), 强迫中断(硬件 - 缺页,软件 - /0)
  - 外中断(中断) - 信号来源于CPU外部
    - 外设请求(I/O),人工干预(Kill)
  - 外中断 : 执行完每个指令后检查有无外部中断信号,若有 - **保留CPU现场环境 - 根据中断信号类型转入相应中断处理程序 - 恢复CPU现场环境**

## 0.2 系统调用

- 概念: 操作系统提供给应用程序/程序员使用的接口,可获得操作系统的服务.
  - 命令接口:命令语句 
  - 程序接口: 用户通过程序间接使用 - 系统调用组成
  - 作用: **系统中的各种共享资源由操作系统管理, 用户程序中与资源有关的操作需通过系统调用方式提出服务请求,由操作系统完成 - 保证系统的稳定性和安全性,防止用户非法操作.**(设备管理, 文件管理, 进程控制, 进程通信, 内存管理)
- 区别于库函数: 应用程序 via 高级语言中的库函数 -> 系统调用 (库函数可能包含系统调用, 隐藏使用细节, 更加方便)

- 系统调用过程 : 传递调用参数 -> 执行陷入指令int (用户) -> 执行系统调用(核心) -> 返回用户程序

![image-20220302131426023](C:\Users\86137\AppData\Roaming\Typora\typora-user-images\image-20220302131426023.png)



# 1. 进程&线程

## 1.1 进程

- 进程(动态)是进程实体(静态)的运行过程，是系统进行资源分配和调度的独立单位
  - 程序段: 程序代码 - 指令序列
  - 数据段: 程序运行时使用\产生的运算数据 (变量\常量...)
  - PCB：(存储与进程管理相关信息)
    - 进程描述信息 : **进程标识符PID - 进程唯一的不重复的ID**; 用户标识符 - 进程所隶属的用户
    - 进程控制管理信息: 进程当前状态, 进程优先级
    - 系统资源分配清单: 程序段指针, 数据段指针, I/O设备(键盘, 鼠标)
    - 处理机信息: 现场环境(各种寄存器值)
- 进程组织方式:
  - 链接方式: 执行指针; 就绪队列指针; 阻塞队列指针
  - 索引方式: 指向索引表 (就绪/阻塞)
- 特征: **动态性**, 并发性, 独立性, 异步性(异步推进), 结构性(组成结构)



## 1.2 进程状态

1. 运行态: 占有CPU并运行
2. 就绪态: 等待CPU空闲
3. 阻塞态: 等待I/O操作
4. 创建态: 创建进程,分配资源,初始化PCB
5. 终止态: 回收资源,撤销PCB



- 状态转换过程:
  
  - ![image-20220302134623074](C:\Users\86137\AppData\Roaming\Typora\typora-user-images\image-20220302134623074.png)
  
  - 引入中级调度后的挂起状态（PCB位于内存 - 记录进程于外存的位置，进程置于外存）
  
    ![image-20220306101211659](C:\Users\86137\AppData\Roaming\Typora\typora-user-images\image-20220306101211659.png)





## 1.3 进程控制(进程状态转换)

- 原语 - 原子操作 : 执行过程不允许中断 - 核心态运行
  - 关中断指令+开中断指令 : 期间会忽略外部中断信号
  - 进程控制相关原语:
    1. 更新PCB中的信息(进程状态标志,保存/恢复现场环境)
    2. 将PCB插入合适的队列
    3. 分配/回收资源



- 创建原语

![image-20220302152353340](C:\Users\86137\AppData\Roaming\Typora\typora-user-images\image-20220302152353340.png)

- 终止原语

![image-20220302152458548](C:\Users\86137\AppData\Roaming\Typora\typora-user-images\image-20220302152458548.png)

- 阻塞/唤醒原语

![image-20220302152551903](C:\Users\86137\AppData\Roaming\Typora\typora-user-images\image-20220302152551903.png)

- 切换原语

![image-20220302152625598](C:\Users\86137\AppData\Roaming\Typora\typora-user-images\image-20220302152625598.png)

## 1.4 进程通信

- 进程之间的信息交换（由于进程之间的同步/互斥）
- 进程通信的类型
  1. 共享存储器系统(互斥)：共享数据结构/共享存储区
  2. 管道通信系统(**半双工,内存中开辟固定大小缓冲区**)：连接一个读进程和一个写进程实现它们之间通信的pipe文件
  3. 消息传递系统：以格式化的消息为单位，将通信数据封装于消息中，利用通信命令进行进程间消息传递
     - 直接通信 : 发送到接收方消息缓冲队列
     - 间接通信: 发送到中间实体中,都进程从中间实体接受消息
  4. 客户机-服务器系统：
     1. 套接字：发送发随机指定一个套接字端口，接收方拥有一个全局公认的套接字和指定端口（80，443）
     2. 远程过程/方法调用RPC：运行于一台主机系统上的进程调用另一台主机上的进程（方法）





## 1.4 ~~~进程调度

- 主要任务：保存处理机现场信息（上下文）；按某种算法选取进程；把处理机分配给进程。
  - 上下文切换：将当前正在运行的CPU中进程/线程数据(寄存器)转移到进程/线程中，将马上要运行的进程/线程中的数据复制到CPU寄存器中
  - sleep(0) 阻塞0s-让出CPU的使用权，当就绪队列中有优先级>=当前线程时将对应线程获得CPU
- 调度方式：
  1. 非抢占方式：执行完毕/阻塞时切换
  2. 抢占方式：优先权/短进程优先/时间片原则
  3. 多级反馈队列调度算法：设置多个就绪队列，根据其优先级设置其时间片大小



## 1.5 线程



线程: 基本的CPU执行单元, 程序执行流的最小单位.

- 引入线程后,进程只作为除CPU外的系统资源的分配单元(I/O设备, 地址空间).



**线程控制块TCB组成**

1. 线程标识符
2. 处理机状态信息
3. 线程调度信息：线程优先级、线程运行状态
4. 线程专属存储区域：线程独有的存储区域（ThreadLocal）
5. 用户栈&内核栈: 线程执行的方法栈，保存线程执行的用户方法/内核方法信息
6. 程序计数器/程序段指针：线程执行指令地址。
   

- 与进程的比较
  - **资源分配调度**: 进程仅资源分配基本单位, 调度基本单位为线程
  - **并发性:** 可支持进程中线程间并发
  - **系统开销**: 同一进程中的线程切换不需切换进程,系统开销小.
  - 地址空间：进程之间地址空间独立；同一进程中线程共享本进程地址空间。
  - 资源拥有：进程间资源独立；同一进程中线程共享本进程资源。
  - 崩溃：进程崩溃不会影响其他进程；线程崩溃会导致拥有这个线程的进程崩溃。



- 线程实现方式

  1. 用户级线程: 由应用程序通过线程库实现, 切换在用户态下完成,对操作系统不透明
     - 多对一模型: 线程切换在用户空间完成,不需切换到核心态;  一个用户及线程阻塞则整个进程阻塞
  2. 内核级线程: 由操作系统内核完成, 切换在核心态下完成, 对操作系统透明
     - 一对一模型: 并发能力强; 线程切换需由操作系统内核完成,开销大
  3. 多对多模型: n个操作系统内核对应m个用户线程 (n>=m)
     - 可控制n/m比例灵活调整

  - **内核级线程才是处理机分配单位.**



# 2. 处理机调度&死锁

## 2.1 调度层次:

1. 高级(作业)调度: 将外存上处于后备队列中的作业调入内存，为其创建进程、分配必要资源，置入就绪队列。
   1. 作业: 用户提交给系统的一项相对独立的工作 - （磁盘 - 后备作业队列 - 调入内存）
      - JCB作业控制块：调度信息、资源需求、作业类型
   2. 作业状态：收容阶段 - 运行阶段 (就绪 - 运行结束) - 完成阶段
   3. 主要任务：根据JCB信息，检查系统中资源能否满足作业需求，按一定调度算法将作业调入内存
2. 低级(进程)调度：进程调度, 就绪队列 -> 运行
   - **进程在操作系统内核程序临界区中不能进行调度与切换**
     - 访问内核程序临界资源时会对临界资源上锁,若不尽快释放会影响操作系统内核其他管理工作, 因此在这期间不会切换直至对内核临界资源访问完毕. (就绪队列)
   - 处理中断的过程不能进行进程切换
   - 原子操作不能进行进程切换
3. 中级(内存)调度：将暂时不用的进程调至外存等待(挂起状态,置于挂起队列), PCB常驻内存, 将外存中内存调入内存. - **提高内存利用率、系统吞吐量**
   - 就绪挂起, 阻塞挂起
     - 阻塞挂起: 等待事件出现时转移至就绪挂起; 激活时转入阻塞态

- 发生频率: 高级 < 中级 < 低级





## 2.2 调度算法

一些评价指标:

- **系统吞吐量 : 单位时间内完成作业的数量  -> 完成作业数 / 完成作业时间**
- 周转时间: 作业从提交到完成花费的时间 -> (<u>外存等待调度 -> 就绪队列等待调度 -> CPU执行时间 -> 完成)</u>
  - 平均周转时间: 各作业周转时间之和 / 作业数量
  - 带权周转时间: 周转时间 / 运行时间
- 等待时间: 作业/进程等待处理机状态的时间 (外存 - 就绪  (不包括等待I/O的时间))
- 相应时间: 用户从提交请求到首次被相应的时间
- 饥饿: 进程/作业长时间得不到调度 (SJF导致)



- HRRN高相应比优先调度算法 - 总和考虑作业/进程的等待时间和服务时间

  - 计算各个相应比 : **<u>(等待时间+要求服务时间) / 要求服务时间</u>**, 优先选择相应比高的服务

  - 综合了SJF与FCFS: 等待时间相同 - 短作业优先;  服务时间相同 - 先来先优先

  - eg. 

    | 进程/作业 | 到达时间 | 运行时间 |
    | --------- | -------- | -------- |
    | p1        | 0        | 7        |
    | p2        | 2        | 4        |
    | p3        | 4        | 1        |
    | p4        | 5        | 4        |

    初始p1到达,先运行; 

    运行完毕时有p2,p3,p4都到达 p2: (5+4)/4=2.25;  p3: (3+1)1=4;  p4:(2+4)/4=1.5  p3运行

    p2:(6+4)/4 = 2.5 p4: (3+4)/4 = 1.75   p2运行

    p4运行   p1 -> p3 -> p2 -> p4

- RR时间片轮转算法 - 始终装置发出时钟中断通知时间片已到

- 优先级调度算法 - 根据任务紧急程度/优先级选择优先级最高的任务

  - 操作系统更偏好I/O繁忙性进程 - IO设备可与CPU并行工作,提高吞吐量 (计算繁忙 - CPU占用长)
  - 动态优先级 : 优先级随任务运行时间改变 (I/O繁忙提高)

- 多级反馈队列调度算法: 优先级调度+时间片轮转

  - 设置多级就绪队列, 优先级越高的就绪队列所分配的时间片越长



## 2.3 进程同步/互斥

- 前置: 进程具有异步性 - 进程以独立的,不可预计的速度向前推进
- 进程同步: 直接制约关系 - 多个任务之间须在位置上协调其工作次序而产生的制约关系 (管道通信的读写进程)
- 进程互斥: 对临界资源的访问即为互斥访问 - 间接制约关系
  - 空闲让进,忙则等待,有限等待(保证有限时间内进入临界区),让权等待(不能进入临界区时释放CPU)



- 临界区分类:
  - 进入区: 检查是否可以进入临界区, 若可以 - 设置访问标志组织其他访问
  - 临界区: 实际访问临界资源的代码
  - 退出区: 解除正在访问临界资源的标志
  - 剩余区: 做一些其他处理



### 2.3.1 实现方法(软件):

1. 单标志法: **只检查不上锁,** 每个进程进入临界区的权限只能由另一个进程赋予  (违背空闲让进 - 待进入临界区的进程不进)
2. 双标志先检查: **先检查后上锁,** 两个标志位, 对侧进程检查对方标志位条件,若对方没进则自己进 (违背忙则等待 - 异步性二者同时访问临界区)
3. 双标志后检查: **先上锁后检查**, (违背空闲让进, 有限等待)
4. Peterson: 基于双标志后检查 + 单标志 - **双方都想进入临界区时主动让对方使用临界区 (违背让权等待)**
   - ![image-20220302183008762](C:\Users\86137\AppData\Roaming\Typora\typora-user-images\image-20220302183008762.png)

### 2.3.2 实现方法(硬件)

1. 中断屏蔽方法: 利用开,关中断指令 与原语类似  (不适用于用户线程/进程)
2. TSL / TestAndSet: 原子操作 (true占用) -  先test, 无论test结果如何都设置为true, 若test结果为false则进入临界区,出来后重新设置为true  (不满足让权等待)
3. Swap指令: 原子操作 - 逻辑上类似于TSL  old = true;  while(old) swap(old, lock);

- 实现方法(信号量)， wait, signal (S)



### 2.3.3 信号量机制

- 一对原语**wait, signal | p, v** 对信号量进行操作 - 实现进程同步/互斥



- 整型信号量: 用整数型变量表示系统中某种资源的数量 wait(s); **(先判断后--)** signal(s);  (不满足让权等待)
- 记录型信号量: 结构体 -> value-资源数 process L->等待队列
  - wait(**先--后判断**):  S.value--;   if(s.value < 0) block(S.L); 自我阻塞 -> 让权等待
  - signal: S,value++;   if(s.value <= 0) wakeup(s,l); 唤醒 - 若s.value<0则等待队列存在等待元素,唤醒一个等待元素



- 信号量机制实现进程同步(前驱)关系
  - **在前操作之后执行v操作;  在后操作之前执行p操作**
  - **<u>实例: 在每条有向边上添加一变量,变量初始值为0;   出度处执行v操作, 入度处执行p操作</u>**



- eg. 多生产者消费者 ->  理清复杂的同步关系
  - ![image-20220304102453833](C:\Users\86137\AppData\Roaming\Typora\typora-user-images\image-20220304102453833.png)
- eg. 哲学家进餐问题
  - 1.对哲学家进行限制 - 最多允许四位哲学家进餐 (mutex)
  - 2.对偶数位哲学家先拿左边筷子, 对奇数位哲学家先拿右边筷子 - 竞争失败的一方没有筷子
  - 3.仅当哲学家可以拿两个筷子时允许就餐 (互斥信号量mutex)

### 2.3.4 管程 - 高级同步机制

- 组成结构

  1. 局部于管程的**共享数据结构**  (仅能被2,3所操作)
  2. 对该数据结构进行操作的一组过程
  3. 对数据结构初始化的语句
  4. 管程所具有的名字(结构体/类名)

  - **每次仅允许一个进程在管程内执行某个内部过程**

## 2.4 死锁

- 产生原因:
  1. 竞争不可抢占资源
  2. 竞争可消耗资源
  3. 进程推进顺序不当



- 死锁定义：一组进程发生死锁时，这组进程中的所有进程都在等待该组进程其他进程才能引发的条件。

  - 区分: 饥饿: 长时间得不到处理机 -> 短作业优先
  - 区分: 死循环: 程序员的问题 循环终止条件永远达不到

- 必要条件:
  1. 互斥条件 - 排它性使用占有资源
  2. 不可抢占
  3. 保持和请求
  4. 循环等待 - 发生死锁必然存在一个循环等待链
  
- 死锁处理方法：
  1. 预防死锁 - 预先设置条件破坏死锁产生的四个必要条件

     - 互斥 : SPOOLing技术 -> 输出进程接受请求置于请求队列

     - 请求和保持：允许一个进程只获得运行初期所需资源便开始运行，运行过程可逐步释放已分配且用完的资源，再请求
     - 不可抢占：提出新的请求无法满足时释放已保持

  2. 避免死锁 - 资源动态分配时防止系统进入不安全状态

     - **银行家算法： 下文详述**

  3. 检测解除死锁 - 允许死锁发生，通过检测脱离

     - 抢占资源/终止进程：抢占所需资源给死锁进程/结束死锁进程



### 银行家算法 **

- 数据结构：

  1. 最大需求矩阵Max[i, j] - 进程i所需j类资源最大数目
  2. 分配矩阵Allocate[i, j] - 进程i已得到的j类资源数目
  3. Need[i, j] - 进程i还需的j类资源数目
  4. Request[i, j] - 进程i申请的j类资源数目
  5. Available[j] - 系统所余j类资源数目

- 步骤:

  1. Request[i, j] <= Need[i, j]  ->2  否则出错(申请资源数目大于所需资源)
  2. Request[i. j] <= Available[j] -> 3 否则i等待
  3. 尝试分配资源
     - Available[j] -= Request[i, j]
     - Need[i, j] -= Request[i, j]
     - Allocate[i, j] += Request[i, j]
  4. 系统执行安全性算法，检测此次分配后系统是否安全，若安全正式将资源分配，否则分配作废

- **安全性算法**

  - Work[j] 表示各类资源(j)的数目，进入时Work = Available
  - Finish[i] 表示各个进程完成情况， 初始false

  1. 从进程集合找到一个满足如下条件进程：Finish[i]=false && Need[i, j] < Work[j]
  2. Work[j] += Need[i, j]; Finish[i] = true;
  3. go to 1
  4. 若所有进程都true则满足安全状态，否则不满足





# 3. 存储器管理

## 3.1 存储器结构

1. 寄存器：与处理机速度相同，对寄存器的访问速度最快，能与CPU完全协调工作
2. 高速缓存：介于寄存器与主存，备份主存中常用数据，减少处理机对主存储器访问次数。
3. 主存储器：内存/主存，保存进程运行时的程序和数据。
4. 磁盘缓存：磁盘I/O速度远低于主存访问速度 - 暂时存放频繁使用的一部分磁盘信息，减少磁盘访问次数



- 存储器管理的功能
  1. 内存空间的分配与回收
  2. 内存空间扩容（虚拟存储器）
  3. 内存空间地址转换 逻辑地址 -> 物理地址
  4. 程序存储保护 -> 进程在自己被分配的内存空间运行，不越界访问 (上下限 / 重定位-界地址)



## 3.2 程序装入和链接

1. 编译：由编译程序对用户源程序进行编译，形成若干目标模块
2. 链接：链接程序将目标模块与所需库函数链接，形成完整装入模块 -> 形成完整逻辑（相对）地址
3. 装入：装入程序将装入模块装入内存
   1. 绝对装入：编译时就知道程序将置于内存中的位置，则编译程序将产生绝对地址的目标代码（而非相对地址） - *只适合于单道程序环境*
   2. 静态重定位：装入程序负责将相对地址转换为绝对地址 （作业装入内存后就分配全部内存空间且不可再申请、移动）
   3. 动态重定位：重定位寄存器存放进程的起始地址，相对地址到绝对地址的转变在地址有关代码执行时发生





## 3.3 连续分配存储管理方式

- 为用户程序分配一个连续的内存空间
- 系统区：仅提供给OS使用；用户区：分配用户内存

1. 单一连续分配

2. 固定分区分配: 划定分区+内存分配

3. 动态分区分配：根据进程需要为之动态分配内存

   - 分配数据结构： 空闲分区表 || 空闲分区链
   - 分区分配方式：FF；NF；BF；WF
   - 分区回收：分区大小 & 起始地址的改变

   - 基于顺序搜索的动态分区分配：**将主存空闲分区连成一条链，顺序搜索空闲分区链寻找合适的分区**
     - FF；NF；BF将空闲分区从小到大顺序形成空闲分区链；WF
   - 基于索引搜索的动态分区分配：~~~~

4. 动态重定位分区分配：不能找到合适的内存空间且紧凑后形成内存大小满足该进程内存



## 3.4 分页存储管理方式

- 将用户程序地址空间分为若干固定大小的区域 - 页/页面；将内存空间也分为若干物理块。 页块大小相等，可将用户程序任一页放入任一物理块中 - 离散分配。



### 3.4.1 分页存储管理基本方法

1. **页面&物理块：将进程逻辑地址空间分为若干页，每页加以编号； 将内存物理空间分为若干块，加以编号。将页分别装入可以不相邻的物理块中。**
1. 逻辑地址对应页号 P = 逻辑地址A / 页面长度L
   2. 页号对应页面在内存中的起始地址  **（页面大小一般为2^n -> 方便计算页号 - 高位、偏移量 - 低位）**
   3. 逻辑地址在页面内的偏移量 W = 逻辑地址A % 页面长度L
   4. 物理地址 = 页号始址+偏移量
   
2. 页表: 保证进程在内存中找到每个页面对应物理块  **页号 - 块号**

   - **页表项长度由该进程页面数量所决定** （最好取2^k整数位方便查询）

     - eg. *页面大小4KB，进程内存大小4GB* : <u>4\*2^30 / 4\*2^10 = 2^20 -> 一共存在2^20范围个页面数量 -> 需要20位 - 3字节来存储页号</u>

     - 页表初始地址为X，则M号页对应页表项存放于内存的X+3*M中，于此查询块地址

3. 地址变换机构：如下

### 3.4.2 地址变换机构



将用户空间的逻辑地址转换为内存空间的物理地址



- 系统设置页表寄存器PTR：存放页表始址F与页表项长度M

  - 进程未执行时，将页表起始地址与页面长度存放于PCB中，调度时置入PTR中

  1. 根据逻辑地址推算出页号P与页内偏移量W
  2. 若P>=M 越界中断
  3. 查询页表，找到对应的物理块号F+M*P
  4. 物理块号与偏移量得到物理地址 -> 访问

  - 页号 - 块号映射:  页表始址 + 页号 * 页表项长度 -> B = F+P*M
  - 物理地址：物理块号与页内偏移量W拼接 B*L(页面大小)+W



- 快表TLB：CPU给出有效地址后，地址变换机构将页号P送入高速缓冲寄存器，将此页号与高速缓存中的所有页号比较，若有则直接从快表中取出物理块号。若快表已满需替换。
  - 局部性原理 - 大多数程序对少量页面进行多次访问。**TLB存储频繁访问页表数据副本，内置于CPU中加快访问速率**



### 3.4.3 两级页表

- 理解如下问题！

  ![image-20220306113105394](C:\Users\86137\AppData\Roaming\Typora\typora-user-images\image-20220306113105394.png)



![image-20220306113717761](C:\Users\86137\AppData\Roaming\Typora\typora-user-images\image-20220306113717761.png)

- 页目录表（顶级页表） 存放内存块好 - 二级页表

  1. 根据一级页号查询页目录表，找到下一级页表对应内存块号
  2. 根据下一级页表查询页号对应物理块号
  3. 结合页内偏移量得到物理地址

  - 注: 若采用多级页表，**则各级页表大小不能超过一个页面**

 



## 3.5 分段式存储管理方式

- 作业地址被分为几个段(按照程序自身逻辑关系)，每个段定义了一组逻辑信息

1. 分段：段号 + 段内地址 - **段内地址由相应的逻辑信息组长度决定**
2. 段表：段号、**段长**、基址
3. 地址变换机构: 基础 & 快表 



- 分页与分段
  - 相同点: 皆采用离散分配方式；地址映射机构实现地址变换
  - 不同点：
    1. 页是信息的物理单位，满足系统分配内存需要，对用户不可见；段是信息的逻辑单位，包含意义相对完整信息，满足用户需要。
    2. 页的大小固定且由系统决定；段的长度不固定，取决于用户编写程序
    3. 分页一维（仅需给出逻辑地址即可） ； 分段二维 - 段号+段内地址  （**对于分段而言，段长不同，不能通过整除求得段号，也不可通过求余得到段内偏移量，二者都需给出**）
    4. 得到段表中的段号基址后，还需判断偏移量是否超过段表中段长（若超过需越界中断）



## 3.6 段页式

- 段号 + 页号 + 偏移量  (段由多个页来存储)

  - **段号位数：进程最多可有的段数；页号位数：每个段最多可有多少页； 偏移量：页面大小**
  - 分段对用户可见，用户需显式给出段号与段内地址
  - 分页对用户不可见，系统根据*段内地址*自动划分页号与偏移量

  1. 根据段号与段内地址得到段表项 （需注意段号是否越界）  （段表项 - 段号、页表长度、页表存放地址）
  2. 根据段表项查询对应的页号 （判断页号是否越界）
  3. 根据页号查询对应物理块号
  4. 根据物理块号与业内偏移量得到物理地址



# 4. 虚拟存储器

- 从逻辑上扩充内存容量
- **局部性原理: 在较短时间内，程序执行仅限于某个部分，所访问的存储空间也仅限于某个区域。**
  - 时间局限性：循环操作 - 指令 | 数据 不久后被再次执行/访问
  - 空间局限性：顺序执行 - 程序访问某个存储单元，不久后其临近存储单元可能被访问



## 4.1 虚拟存储器定义&特征

1. 定义：具有请求调入功能和置换功能，能从逻辑上将内存容量加以扩容的一种存储器系统。
2. 特征：
   1. 多次性：一个作业中的程序和数据被分成多次调入内存中运行
   2. 对换性：一个作业中的程序和数据允许在作业运行过程换进换出内存
   3. 虚拟性：从逻辑上扩充内存容量



## 4.2 实现方式

- 基于离散分配存储管理方式



### 4.2.1 硬件支持

- 分页/段 + 请求调页/段 + 页/段置换功能
  - 请求页表机制
    - 页号、物理块号
    - 状态位P: 指示该页是否已调入内存 - 程序访问
    - 访问字段A: 本页在一段时间内被访问次数/多长时间未被访问 - 页面置换算法
    - 修改位M: 标识该页在调入内存后是否被修改过 - 置换页面
    - 外存地址
  - 缺页中断机制：要访问的页面不在内存时产生，将缺页调入内存。
    - **区别于一般中断：指令执行期间产生、处理；一条指令执行期间产生多次缺页中断**
  - 地址变换机构



### 4.2.2 内存分配策略

1. 保证进程正常运行所需的最小物理块数确定
   - **驻留集：请求分页存储管理中给进程分配的物理块的集合**
   - **工作集：某段时间间隔内，进程实际访问的页面集合**
   - <u>工作集根据窗口尺寸（最近连续访问的n个页面）滑动窗口 计算</u>，驻留集>=工作集
2. 为每个进程分配物理块时策略
   1. 固定分配局部置换：分配固定数目物理块，只能从分配页面中选取一页换出
   2. 可变分配全局置换：动态分配物理块数目，内存不空闲时选择一<u>未锁定(内核数据)</u>的页面换出，调入缺页  （只要缺页就会增加物理块数目 - 被选中换页的进程物理块数目减少）
   3. 可变分配局部置换：动态分配物理块数目，发生缺页时从已分配物理块中选择换出 - 缺页频繁时可适当增加物理块数目 
3. 物理块分配算法：平均/按比例/优先权



### 4.2.3 页面调入策略

1. 何时调入页面：预调页（进程首次调入时采用 - 程序员指出先调入部分）、请求调页 - 缺页时发生
2. 从何处调入：  （磁盘：*对换区 - 连续分配方式 / 文件区 - 离散分配方式*）
   1. 对换区空间足够：内存与对换区间进行
   2. 缺少足够对换区：不会被修改的数据从文件区调入、可能修改部分换出时先写入对换区，下次需要时再从对换区调入
   3. UNIX方式: 未使用过的页面从文件区调入；曾运行过的页面从对换区调入
3. 页面调入过程：**程序发现所要访问页面未在内存中时，向CPU发出缺页中断，中断处理程序首先保存CPU环境**，分析中断原因后转入缺页中断处理程序。
4. 缺页率：页面大小、进程分配物理块数、页面置换算法 f = F/(F+S)



- 请求调页方式

  ![image-20220306162847639](C:\Users\86137\AppData\Roaming\Typora\typora-user-images\image-20220306162847639.png)

- 区别于基本分页的地方

  1. 需判断对应页表项是否在内存中（状态位P）
  2. 若页面不在内存中需请求调页
  3. 若内存空间不够还需页面置换
  4. 对应页面调入内存后需修改块表/页表项





## 4.3 页面置换算法

- 抖动：刚换出的页不久又要被访问，需置换调出；被调出的页又不久被访问。
- Belady异常 - 为进程分配物理块增多时，缺页次数反而增加

1. FIFO
2. LRU最近最久未使用：队列 - 用到队尾，满时排除队首 / 移位寄存器 - 每个页面配置一个移位寄存器，用到该页时将高位置1，每固定时间将寄存器右移1为，满时置换最小寄存器数页面
3. LFU最少使用：
4. Clock - FIFO+访问位A : 某页面被访问时访问位置1， 页面满时FIFO，若访问位1则置0；访问位0则置换
   - 改进型 A + M: 0-0 未访问未修改最佳； 0-1未访问已修改； 1-0已访问未修改； 1-1已访问已修改
   - 第一轮扫描找0-0(未访问未修改)；第二轮扫描找0-1且置A为0(没访问已修改)；第三轮找0-0(已访问没修改)； 第四轮找0-1(已访问已修改)
5. 页面缓冲算法PBA：
   - 空闲页面链表：系统掌握的空闲物理块，分配给频繁缺页的进程；有一个未被修改页换出时将其物理块挂在空闲链表末尾
   - 修改页面链表：已修改页面形成链表，减少已修改页面换出次数，降低写回磁盘频率



# 5. 磁盘

## 5.1 磁盘地址结构 & 优化

<img src="C:\Users\86137\AppData\Roaming\Typora\typora-user-images\image-20220502154305882.png" alt="image-20220502154305882" style="zoom:67%;" />

磁盘地址结构高位到低位：柱面号,盘面号,扇区号

- 柱面：圆环结构由内到外
- 盘面：磁盘盘面由上倒下
- 扇区：磁盘扇区
- 原因：减少读取连续地址空间所需时间，**扇区低地址，滑动过程不需移动磁臂； 盘面中地址，减少激活磁盘耗时； 柱面高地址，减少磁盘寻道时间**



扇区错位命名：磁头读取数据时读取完一个扇区不能立刻读取下一个扇区，而若地址空间连续则临近扇区数据不能马上读取只能等待下一次旋转到位，因此采用扇区错位命名提高扇区读取效率。



磁盘控制器：根据逻辑块号来标识（盘面、磁道、扇区）三元组信息来唯一标识每一个物理扇区；并根据三元组信息来进行启动磁臂、跨越磁道等读取操作。

## 5.2 磁盘调度算法

一次磁盘读/写所需时间：

- 寻道时间Ts : 读/写数据前将磁头移动到指定磁道所需时间 Ts = s + m * n  (**启动磁头臂 + 跨越磁道数 * per磁道耗时**)

- 延迟时间Tr：旋转磁盘将磁头定位到目标扇区所需时间   Tr = (1/2)*(1/r) **r为磁盘转速，1/2平均转动转数**

- 传输时间Tt: 从磁盘读出/向磁盘写入数据所需时间

  Tt = (1/r) * (b/N) **b读写字节数；N每个磁道上字节数**

- **延迟时间与传输时间仅与磁盘转速有关，优化空间少；*而寻道时间跨越磁道数可通过磁盘调度算法进行相应优化***



磁盘调度算法：

- 先来先服务: 根据进程请求磁盘的先后顺序进行调度。
  - 磁头由初始磁道号先后访问进程请求访问的磁道号。
- 最短寻找时间有限：优先处理与磁头最近的磁道。
- SCAN扫描算法(电梯算法)：磁头只有移动到边界时才能更改移动方向。
  - 相较最短寻找时间，不会产生饥饿现象。
- C-SCAN循环调度算法：朝一个方向移动时处理磁道访问请求；朝另一个返回时不再处理访问请求而是快速移动到起始端。
  - 处理相应不均情况
- LOOK调度算法：磁头移动方向上无请求了就可改变请求方向。 （无需移动到边界）
- CLOOK调度算法：不需移动到边界。



## 5.3 固态硬盘

固态硬盘由一个/多个闪存芯片组成，使用闪存芯片代替传动臂+盘片实现数据存储访问.

- 由半导体存储器而非移动机械部件，随机访问时间快。

- 闪存转换层：类似于磁盘控制器，将操作系统对逻辑块的请求翻译成对底层物理设备的访问

层级结构：die -> plane -> block -> page

操作类型：读取、写入、擦除

- 写入：将1修改为0
- 擦除：将所有存储位变成1. 擦除操作可能造成块受损.

# 6.I/O设备

## 6.1 I/O控制器

I/O设备的电子部件，作为CPU和I/O设备机械部件之间的中介，实现CPU对设备的控制。



作用

1. 接受、识别CPU发出的命令
   - 控制寄存器，存放CPU发出的命令、命令参数
2. 向CPU报告设备状态
   - 状态寄存器，表示设备当前状态 空闲/忙碌
3. 数据交换
   - 数据寄存器：暂存缓冲
4. 地址识别
   - 区分设备控制器中的各个寄存器，给寄存器设定特定地址。



组成：

- <img src="C:\Users\86137\AppData\Roaming\Typora\typora-user-images\image-20220502160330150.png" alt="image-20220502160330150" style="zoom:67%;" />

- CPU与控制器接口： **实现CPU与控制器之间的通信，CPU通过控制线发出命令；通过地址线指明要操作的设备；通过数据线来读/写数据**
- I/O逻辑 : *负责接受、识别CPU各种命令，负责对设备发出命令*
- 控制器与设备接口： 实现控制器和I/O设备之间通信。



I/O控制器寄存器编址方式： 内存映像I/O与寄存器独立编址：

- 内存映像I/O：寄存器占用内存地址的一部分, **控制器中寄存器内存地址统一编址** n~n+x
  - 可采用对内存操作指令来操作控制器
- 寄存器独立编址：I/O专用地址，I/O控制器中寄存器独立编址0~x
  - 需指明控制器编号与对应寄存器地址



## 6.2 I/O控制方式

- 程序直接控制方式 **CPU轮询操作** （eg. 读操作）

  <img src="C:\Users\86137\AppData\Roaming\Typora\typora-user-images\image-20220502161933930.png" alt="image-20220502161933930" style="zoom:%;" />



<img src="C:\Users\86137\AppData\Roaming\Typora\typora-user-images\image-20220502162153331.png" alt="image-20220502162153331" style="zoom:50%;" />

- 中断驱动方式 **引入中断机制，CPU发出读/写命令后可将等待I/O进程阻塞以切换到别的进程执行； I/O操作完成后控制器向CPU发出中断信号，CPU响应中断处理。**

  - 区别于程序直接控制 : 轮询 -> 中断响应；使得CPU与I/O设备并行工作。

- DMA方式直接存储器存取

  <img src="C:\Users\86137\AppData\Roaming\Typora\typora-user-images\image-20220502163434709.png" alt="image-20220502163434709" style="zoom:50%;" />

  1. 数据传送单位：字 -> 块
     - **DMA每次读/写连续的多个块，且块读/写内存地址也必须是连续的**
  2. 数据流向： 设备 <-> 内存
  3. CPU干预频率进一步降低： 传送数据块的开始/结束时

- 通道读取方式 : 识别并执行一系列通道指令。
  1. CPU向通道发出I/O指令指明通道程序在内存中位置以及要操作的I/O设备
  2. 通道执行内存中的通道程序
  3. 通道执行完任务后向CPU发出中断信号供响应处理。



## 6.3 I/O软件层次结构

用户层软件: 实现与用户交互接口，用户可直接使用该层所提供的与I/O操作相关的库函数对设备进行操作。

设备独立性(无关性)软件：

1. 向上层提供统一的调用接口
2. 实现设备保护 (管理调度、访问权限)
3. 差错处理
4. 设备的分配与回收
5. LUT建立逻辑设备名到物理设备名之间映射，选择相应驱动程序调用。  **逻辑设备-物理设备-驱动程序入口地址**

设备驱动程序：负责对硬件设备的具体控制，将上层发出一系列命令转化为特定设备的一系列操作

## 6.4 SPOOLing 假脱机

脱机技术： 纸带 -> CPU -> 纸带  =>  纸带 -> 磁带 -> CPU -> 磁带 -> 纸带

- 在外围控制机的协助下进行纸带与磁带间的相互转化；即使CPU忙碌也可将纸带转化为磁带，即使纸带忙碌也可将CPU数据输出到为磁带。



SPOOLing 假脱机技术，用软件方式模拟脱机技术

![capture_20220502171059064](D:\Huawei Share\Screenshot\capture_20220502171059064.bmp)



- 输入/输出井模拟脱机情况下的磁带
- 输入/输出进程模拟脱机情况下的外围控制机



# Question

1. 零拷贝？ 内存映像I/O