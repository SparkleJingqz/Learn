> JVM内存结构 - U2
>
> GC垃圾回收 - U3
>
> 字节码执行机制 - U6
>
> 类加载 - U7
>
> JVM性能监控故障处理 - U4
>
> JVM性能调优 - U5



# 类加载机制

类加载器：加载Class文件

## 双亲委派机制

1. 类加载器收到类加载的请求
2. 将这个请求向上委托给父类加载器去完成，一直向上委托，直到启动类加载器
3. 启动类加载器检查是否能够加载当前类，若能则结束；否则抛出异常，通知子加载器进行加载。
4. 重复步骤3直至找到能加载的类加载器
5. 若找不到则抛出Class Not Found异常 



## Native关键字

- 凡是写代了native关键字的方法，说明java的作用范围无法达到，需调用本地方法
  - 进入本地方法栈， 调用本地方法接口JNI
  - JNI在内存区域专门开辟一块标记区域，标记native方法；最终执行时加载本地方法库中的方法
    - *JNI : 扩展Java，融合不同的编程语言为java所用*
- 例子： Socket，WebService



## PC寄存器

- 程序计数器 - Program Counter Register (占用很小的内存空间)
- 每个线程都有的一个程序计数器，线程私有，是一个指向方法区中方法字节码（存储要执行的指令代码的地址）的指针，在执行引擎读取下一条指令。



## 方法区

- 被所有线程共享，所有字段和方法字节码以及一些特殊方法。
  - 所有定义的方法信息都存储在该区域，属于共享区间 (构造函数，接口代码)
- **static静态变量，final常量，Class类信息(构造方法，接口)，运行时常量池存储在方法区中，实际变量存储在堆内存中。**





## 方法栈

1. main()方法被执行，压入栈
2. main方法中的test方法执行，压入栈
3. 若test仍有方法要执行，压栈；否则test出栈
4. main出栈



- 栈内存：主管程序的运行，生命周期和线程同步
  - **线程结束，栈内存就释放； - 栈不存在垃圾回收问题**
- 栈存放内容 : 8大基本类型，对象引用，实例方法
- 栈运行原理: 栈帧 - 



- 栈中方法结构
  1. 方法索引index
  2. 输入输出参数
  3. 本地变量
  4. Class File引用
  5. 父帧
  6. 子帧



- 栈溢出实例： 方法反复调用 (a调用b，b调用a)
  - *抛出StackOverFlowError错误*



- 栈，堆，常量池关系
  - 栈中的引用引用到堆中的实例
  - 堆中常量有关常量从常量池中取
  - new一个Class类的过程，向栈中创建引用名称，然后在堆中实例化类





## 堆

- 一个JVM只有一个堆内存，堆内存大小可以调节
  - 类加载器读取了类文件之后，将类、方法、常量、变量、引用类型真实对象保存至堆中。
- 堆内存包含三个区域
  - 新生代
    - 伊甸园 Eden Space
    - 幸存0区
    - 幸存1区
  - 老年代
  - 永久代（JDK8以后：元空间）
  - GC垃圾回收主要在伊甸园与老年代
- 若堆内存满 -> OutOfMemory 堆内存不够





- 遇到OOM故障的排除策略：
  - 内存快照分析工具：查看出错行数 MAT ,Jprofiler





# U2-Java内存区域与内存溢出异常

## Question:

1. Java内存区域

   - 运行时数据区：Java虚拟机在执行Java程序的过程会将其所管理的内存划分为若干个不同的数据区域 - 统称为运行时数据区。

   1. 程序计数器：当前线程的字节码行号指示器，字节码解释器通过改变程序计数器来指示下一条需要执行的字节码指令。
   2. Java虚拟机栈
   3. 本地方法栈
   4. 方法区
   5. 堆

2. 对象创建过程

   1. 检查类加载与否 - (能否在常量池中定位到一个类的符号引用，检查符号引用代表的类是否已被加载)，若无，先执行类加载过程
   2. 加载通过后，为新生对象分配内存并赋予初始值，设置对象头信息，执行构造函数，完成对象的初始化创建。

3. 内存溢出 - OutOfMemoryError/StackOverFlowError

   - OOM：堆内存不够用 - while死循环反复appand
   - SOF：栈溢出 - A调用B，B调用A

4. JVM参数：

   - -XX:+PrintGC 每次触发GC的时候打印相关日志
   - -XX:+PrintGCDetails 更详细的GC日志
   - -XX:+UseSerialGC 串行回收
   - -Xms 堆初始值
   - -Xmx 堆最大可用值
   - -Xmn 新生代堆最大可用值
   - -XX:NewSize：新生代大小
   - -XX:NewRatio 新生代和老生代占比
   - -XX:SurvivorRatio 用来设置新生代中eden空间和survivoe空间的比例.
     - XX:SurvivorRatio=？
   - -XX: MaxGCPauseMillis: 最大垃圾收集停顿时间 - Parallel Scanvange
   - **总结:在实际工作中，我们可以直接将初始的堆大小与最大堆大小相等，这样的好处是可以减少程序运行时垃圾回收次数，从而提高效率。**





## 2.2 运行时数据区



### 2.2.1 程序计数器（PC寄存器）

- 当前线程所执行的*字节码*的行号指示器，(Java方法)记录正在执行的*虚拟机字节码指令地址* - **字节码解释器通过改变该值来选取下一条需要执行的字节码指令**。
  - 程序控制流的指示器
- **线程私有内存**：对多线程而言，每条线程都需有一个独立的程序计数器，各线程间计数器互不影响，独立存储
  - Java虚拟机多线程实现方法：**时间片轮转法** - 通过线程轮流切换、分配处理器执行时间方式
- 对于Native方法，计数器值为空 - Undefined



### 2.2.2 Java虚拟机栈

- **线程私有内存**，生命周期与线程相同

- 作用：描述Java方法执行的*线程内存模型*

  - **每个方法执行时，Java虚拟机会同步创建一个*栈帧，存储局部变量表、操作数栈、动态链接、方法出口等信息。***
    - 局部变量表: 存储编译期可知的Java虚拟机基本数据类型、对象引用、returnAddress(指向一条字节码指令的地址)
      - 存储方式 - 32位局部变量槽Slot
  - **每个方法被调用直至执行完毕的过程，就对应一个栈帧在虚拟机栈中从入栈到出栈的过程。**

  

- StackOverFlowError: 若线程请求的栈深度大于虚拟机所允许

  - 实例: 方法反复调用 -> 方法a调用方法b，方法b调用方法a

- OutOfMemoryError: (HotSpot不可以，但可以申请时就失败) 对于可以动态扩展发的虚拟机栈容量，扩展时无法申请到足够的内存



- 区别于本地方法栈：为虚拟机执行Java方法服务



### 2.2.3 本地方法栈

- 为虚拟机执行本地方法服务
- 其他地方类似于Java虚拟机栈。



**扩展：本地方法与native关键字**

- 凡是写代了native关键字的方法，说明java的作用范围无法达到，需调用本地方法
  - 进入本地方法栈， 调用本地方法接口JNI
  - JNI在内存区域专门开辟一块标记区域，标记native方法；最终执行时加载本地方法库中的方法
    - *JNI : 扩展Java，融合不同的编程语言为java所用*
- 例子： Socket，WebService



### 2.2.4 Java堆

- 所有线程共享的内存区域，虚拟机启动时创建。
  - **堆中仍可划分出多个线程私有的分配缓冲区TLAB以提升对象分配时的效率。**
  - 换言之，对堆细分的目的只有二者：**更好地回收内存与分配内存。**
- 作用：(几乎所有) 存放实例对象， **所有的对象实例以及数组都应当在堆上分配**
- 别名-GC堆: 垃圾收集器管理的内存区域 (99%GC过程在此进行)
- 内存划分：Java堆可以物理不连续但逻辑连续；既可固定大小又可扩展
  - 主流：物理连续，可扩展。



- OutOfMemoryError：Java堆中没有内存完成实例分配且堆再也无法扩展时。





### 2.2.5 方法区

- 线程共享
- 作用：**存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存数据**
- 非堆:  堆的逻辑部分，区分于堆。 （位于JVM本地内存的元空间）
  - JDK8之前方法区置于永久代中，JDK8开始永久代被废弃，**方法区被置于本地内存实现的元空间。**
    -  -Xmx1004m 与 maxMemory()   读取数据有差异即来源于元空间



- OutOfMemoryError: 方法区无法满足内存分配需求时



### 2.2.6 运行时常量池



- 方法区的一部分
- 作用：Class文件中的常量池表存放Class文件编译期生成的各种字面量与符号引用，**常量池表在类加载后存放到方法区的运行时常量池中。**
  - 运行期间也可将新的常量置入运行时常量池中 - <u>*String的intern()*</u>
  - 对于运行时常量池部分的Class文件，Java虚拟机没有任何细节要求。（Class文件其他部分有严格的摸板规范要求）



- OutOfMemoryError : 常量池无法申请到内存时





### 2.2.7 直接内存

- 非Java虚拟机中定义的内存区域，但被频繁使用且会引起OOM异常。



- NIO(New Input/Output类) - **基于通道与缓冲区的I/O方式，可使用Native函数库直接分配堆外内存，通过存储在Java堆里面的DirectByteBuffer对象作为该块内存的引用进行操作**
  - 避免了Java堆和Native堆中来回赋值数据，提高性能



## 2.3 HotSpot虚拟机对象



### 2.3.1 对象的创建

- **Java虚拟机遇到字节码new指令时，先去检查该指令参数能否在常量池中定位到一个类符号引用，并检查该符号代表的类是否被加载、解析和初始化。**(若无则必须先执行响应的类加载过程)



- 类加载检查通过后，

  - 为对象分配内存：把一块确定大小的内存从Java堆中划分出来(所需内存大小在类加载完成后便可完全确定)

    - **指针碰撞：将未使用的内存与使用过的内存分侧存储，指针指向分界点。分配内存时将指针向空闲方向移动确定的与对象大小相等的内存大小。**

    - **空闲列表：虚拟机维护一个列表记录哪些内存可用，在分配时从列表找到足够大的空间划分给对象实例并更新纪录列表。**
- 选取依据：*基于规整与否的Java堆内存，即垃圾收集器是否带有空间压缩功能*
  
- 线程安全策略： **-XX: +/-UseTLAB**
      
  1. 分配内存同步处理：**CAS配上失败重试**的方式保证更新操作的原子性
     
  2. 本地线程缓冲区TLAB：每个线程在Java堆中预先分配一小块内存-本地分配缓冲区，哪个线程要分配内存就先在对应的本地缓冲区中分配，本地缓冲区用完时才进行同步锁定。
  
- 虚拟机将分配的内存空间都初始化为0值 （若使用TLAB可提前至TLAB分配时进行）- 保证对象实例字段不赋初值即可使用。
  
- 对对象进行必要设置 - 存储于对象头(类实例归属、如何找到元数据信息、对象哈希码、GC分代年龄。。。)
  
- 构造完成：一般而言new指令后会接着执行\<init>()方法按意愿对对象初始化。



### 2.3.2 对象的内存布局

- 对象在堆内存中的存储布局: 对象头、实例数据、对齐填充



- 对象头 - 两部分信息
  - 32/64位Mark Word - **存储对象自身的运行时数据(标志)**：哈希码、GC分代年龄、锁状态标指、线程持有的锁、偏向线程ID。。。
    - 对象自身定义数据无关的额外存储成本，根据对象状态复用自身存储空间
  - 类型指针： **指向其类型元数据的指针，确定该对象为哪个类的实例。**
    - 不一定通过对象本身来查找
- 实例数据：对象真正存储的有效信息 - 父类继承/子类定义字段
  - 分配顺序：受虚拟机分配策略参数-XX: FieldsAllocationStyle 与 Java源码中定义顺序影响
    - 默认：longs/double, ints, showts/chars, bytes/booleans, oops - 相同字段宽度分配在一起
- 对齐填充：占位符 8字节整数倍的占位符



### 2.3.3 对象的访问定位

```yaml
对象实例数据（堆）:对象中各个实例字段的数据
对象类型数据（方法区）：对象的类型、父类、实现的接口、方法等
静态区（也在方法区中）用来存放静态变量，静态块
```



- 通过栈上的reference数据来操作堆上的具体对象 
  - reference：指向对象的引用
  - 方法1-句柄池：reference->句柄池->实例数据/类型数据
    - 句柄池中存储到对象实例数据与类型数据的指针
  - 方法2-指针：reference->实例数据/类型数据的指针->类型数据





# U3 - 垃圾回收

## Question:

1. 判断对象已死的算法
2. 垃圾回收算法
3. （引用关系？）
4. 垃圾回收器种类



## 3.2 对象已死算法

- 垃圾收集器堆回收之前确定哪些对象还存活，哪些已死去

### 1. 引用计数算法

- 内容：为对象添加一个引用计数器，每当其被引用计数器值+1；引用失效时计数器值-1；计数器为0的对象就是不能再被使用的。



优点：内存管理操作被平摊到程序执行过程中（程序执行过程维护引用计数）；内存管理不需要了解runtime的实现细节，维护对象上的引用计数就完成了内存管理（智能指针）



缺点：

1. 维护引用计数开销较大，需通过原子操作保证引用计数的原子性、可见性

2. 无法回收环形数据结构：循环引用

3. 内存开销：每个引用都要维护一个引用计数空间
4. 回收内存是仍引起暂停？

### 2. 可达性分析算法

- 内容：通过一系列GC Roots根对象作为起始节点集，从这些节点开始根据引用关系向下搜索，搜索路径为“引用链”，若一个对象到GC Roots之间没有任何引用链则该对象不能再被使用。
- **GC Roots:**
  1. 虚拟机栈中引用的对象
  2. 方法区类静态属性引用对象
  3. 方法区常量引用对象
  4. 本地方法栈JNI引用对象
  5. JVM内部引用（Class、异常、类加载器）
  6. 同步锁Synchronized持有的对象

### 3. 引用类型

- 强引用Strongly：类似-Object obj = new Object(); 只要强引用关系还在，垃圾收集器就不会回收掉被引用对象。
- 软引用Soft：描述一些**还有用但非必须的对象**。*被软引用关联对象在系统将要内存溢出前将这些对象列入回收范围进行二次回收，若还无足够内存才抛出OOM*
- 弱引用Weak：描述非必须对象，只能生存到下一次垃圾收集发生前。
- 虚引用Phantom：为对象设置虚引用关联唯一目的 - 为能在该对象被收集器回收时收到一个系统通知。*不可被实例化且对其生存时间无影响。*



### 4. 对象死亡/生存

- 对象逃脱死亡 - finalize()方法

  - **任何一个对象的finalize()方法只会被系统调用一次，下一次回收时该方法不会被执行**

  1. 对象可达性分析后没有与GC Roots关联引用链，则被第一次标记，随后第一次筛选，筛选条件为此对象是否有必要执行finalize()方法 （*若没有重写finalize()或者finalize()已被虚拟机调用则没有必要执行*）
  2. 若有必要执行finalize()方法，则该对象被置于F-Queue队列，并稍后由虚拟机自动建立的低调度优先级Finalizer线程去执行其finalize()方法。

### 5. 方法区回收

- 方法区垃圾回收类容：**废弃的常量与不再使用的类型**。
  - 废弃的常量：没有任何对象引用该常量且虚拟机无其它地方引用该字面量 - 确有必要时而非绝对
  - 不再使用的类型： - 被允许回收，非绝对
    1. Java堆中不存在该类及其派生子类实例
    2. 加载该类的类加载器已被回收
    3. 该类对应的Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类方法。

## 3.3 垃圾收集算法

#### 1. 分代收集理论

- 原则: 垃圾收集器将Java堆划分为不同区域，将回收对象依据其**年龄（对象熬过垃圾收集过程的次数）**分配到不同区域中存储。（兼顾垃圾收集的时间开销和内存空间的有效利用）

- 建立依据：

  1. 弱分代假说: 绝大多数对象朝生夕灭。
  2. 强分代假说: 熬过越多次垃圾收集过程的对象越难以消亡。
  3. 跨代引用假说：跨代引用相对于同代引用仅占少数。

  - 基于12：收集器将Java堆划分为不同区域，依据对象年龄分配到不同区域存储集中回收。(<u>老年代难以消亡，故该引用会使得新生代对象回收时得以存活最终步入老年代 - 消除跨代引用</u>)
  - 基于3：***记忆集***: 在**新生代**上建立一个全局数据结构, 该结构将老年代划分为若干小块，标识出老年代哪一块内存存在跨代引用。MinorGC时只有包含了跨代应用的小块内存里的对象才会被加入GC Roots进行扫描。

- 收集种类：
  1. Partial GC：不是完整收集整个Java堆
     1. Minor GC/Young GC：目标只是新生代的垃圾收集
     2. Major/Old GC：目标只有老年代的垃圾收集。
     3. Mixed GC：收集整个新生代以及部分老年代
  2. Full GC: 收集整个**Java堆和方法区**

#### 2. 标记清除算法

- 内容：
  1. 标记阶段：标记所有需要回收/存活的对象
  2. 清楚：清楚所有需要回收/未标记存活的对象
- 缺点：标记清楚效率较低；清楚之后造成内存空间碎片化



#### 3. 标记复制算法

- 内容：将可用内存按容量分为大小相等两块，每次只用一块。使用完毕时将存活对象复制到另一块内存然后将已使用内存全部清理。
- 缺点：存活对象过多时复制时间开销大；空间浪费大-1/2

- **Appel式回收：将新生代分为一块较大的Eden空间和两块较小的Survivor空间，每次分配只使用Eden和其中一块Survivor。垃圾收集时将Eden和Survivor仍存活对象复制到另一块Survivor然后直接清理掉Eden和已使用Survivor。**
  - 原理:新生代对象有98%熬不过第一轮收集；按8：1：1比率分配Eden和Survivor
  - *补充: 逃生门-Survivor不足以容纳一次Minor GC后存活对象时需依赖其他内存区域（老年代）分配担保。*



#### 4. 标记整理算法

- 内容：标记阶段相同于标记清除，后续让所有存活对象向内存空间一端移动，然后直接清理掉边界以外的内存。（直接清除替换为移动后清除）
- 优缺点-对比标记清除：
  - 优点: 减少内存空间碎片化，便于大对象的分配
  - 缺点: 移动对象的过程复杂且需暂停用户活动。



## 3.5 垃圾收集器

### 1. Serial收集器 new

- 基于标记复制 - 单线程收集器-使用时必须暂停其他所有工作线程直至其收集结束。
- 优点: 简单高效，额外内存消耗最小；没有线程交互开销，单线程手机效率高。

### 2. Serial收集器 old

- 基于标记整理算法

### 3. ParNew收集器new（合并入CMS）

- Serial收集器的多线程并行版本（*只有它/Serial能与CMS收集器配合工作*）
  - 使用CMS后的默认新生代收集器

### 4. Parallel Scavenge收集器 new

- 基于标志复制，类似于ParNew的并行多线程收集器
- *吞吐量优先收集器* - 关注点：**达到一个可控制的吞吐量**(运行用户代码时间与处理器总消耗时间(用户代码+垃圾收集)比值)
  - 最大垃圾收集停顿时间-XX: MaxGCPauseMillis  （缩小新生代空间、牺牲吞吐量）
  - 垃圾收集时间比率-XX: GCTimeRatio
- 自适应调节策略：-XX: +UseAdaptiveSizePolicy 开关参数，*激活后虚拟机会根据系统执行情况收集性能监控信息，动态调整这些参数以提供最合适停顿时间与吞吐量。*

### 5. Paraller old

- Parallel Scavenge老年代版本，基于标记整理



*混合写屏障？*

**对象消失问题满足条件：**

1. **插入了从黑色对象到白色对象的新引用**
2. **删除了从灰色对象到白色对象的直接/间接引用**

处理策略：

1. 增量更新CMS：破坏条件1，有新引用插入时将这个引用记录，并发标记结束后将这些引用记录中的黑色对象为跟重新扫描。
2. 原始快照SATB - G1：破坏条件2，灰色对象要删除指向白色对象的引用关系时将这个**删除引用记录**，并发标记阶段结束后将记录的灰色对象为根重新扫描。  (规避误删风险)

### 6. CMS收集器

- 目标：获取最短回收停顿时间
- 基于**标记清除**算法 - 四个步骤 *(stw - stop the world)*
  1. 初始标记：stw - 标记GC Roots能直接关联到的对象
  2. 并发标记：从GC Roots直接关联对象开始遍历整个对象图 - 耗时较长但可与用户线程并发运行
  3. 重新标记：stw - 修正并发标记期间用户程序运作导致标记变动的对象的标记记录。
     - 增量更新方法标记
  4. 并发清除：清除标记阶段判断为死亡的对象
- Full GC: 标记清除导致内存空间碎片过多，无法为对象分配到足够大空间。



### 7. G1 - Garbage First收集器

- Mixed GC  **基于标记复制**，**面向堆内存任何部分组成回收集进行回收** - 衡量标准：哪块内存中存放垃圾数最多，回收收益最大
- **实现方式：将连续的Java堆划分为多个大小相等的独立区域，每个区域(Region)都可以根据需要扮演新生代Eden/Survivor, 老年代。收集器对不同角色的区域采用不同策略处理。**
  
  - 设置Region：-XX: G1HeapRegionSize 1mb~32mb 2^n
  - 特殊Humongous区域: 存储大对象(超过Region/2)，一般看作老年代进行处理
- **策略: 将Region作为单次回收最小单元 - G1跟踪各个Region里面垃圾堆积的价值(回收所获得的空间大小以及回收所需时间经验值)大小，后台维护一个根据经验的优先级列表。每次根据用户设定的允许停顿时间来有限处理回收经验值大的那些region** - G1在有限时间内获取尽可能高的收集效率
  
  - 用户线程改变对象引用关系: 原始快照算法SATB
  - 回收过程新对象内存分配：为Region设置TAMS指针，将Region一部分空间划分出来用户并发回收过程对象分配。
  - **Full GC: 内存回收速度赶不上内存分配速度。**
  
- **运行步骤:**
  
  - TAMS指针：G1为每个Region设计两个TAMS指针，将Region一部分空间划分出来用于并发回收时新对象的分配，新对象的对象地址必须基于TAMS指针之上。
  
  1. 初始标记：stw - 标记一下GC Roots能直接关联到的对象, 修改TAMS指针使得并发运行时能正确在可用Region中分配新对象。
  2. 并发标记：从GC Root开始对堆中对象进行可达性分析，递归扫描堆对象图，找出要回收对象。扫描结束后处理SATB下并发时有引用变动对象。
  3. 最终标记：stw - 处理并发阶段结束后仍遗留下来的少量SATB。 (2阶段处理SATB时仍可能继续产生SATB)
  4. 筛选回收：stw - 更新Region统计数据，对各个Region回收价值和成本排序，根据用户期望停顿时间指定回收计划， 回收区Region存活对象复制过来再清理回收区Region。 **= 标记复制**







# U6-类文件结构

## 6.2 无关性

Java虚拟机不与任何程序语言绑定，只与Class文件这种特定二进制文件格式关联。



- 平台无关性 - 所有Java虚拟机平台都支持的程序存储结构-**字节码**
- 语言无关性 - **虚拟机和字节码存储格式**
  - **语言(Java) -> 编译器(javac) -> 字节码.class -> Java虚拟机**



## 6.3 Class类文件结构

- 存储单位：一组以8个字节为基础单位的二进制流，无任何分隔符（否则按照高位在前的方式分隔成若干个8字节进行存储）
- 存储结构：类似于C语言结构体，只有两种数据类型 - 无符号数、表
  - 无符号数: u1,u2,u4,u8表示1~8个字节的无符号数，**用来描述数字、索引引用、数量值或按照UTF-8编码构成的字符串。**
  - 表: 由多个无符号数或其他表作为数据项构成的复合数据区域 格式：_info结尾

## 6.4 字节码指令

- 字节码：Java虚拟机的指令由一个字节长度、代表某种特定操作含义的数字**(操作码)**以及跟随其后的0~n个代表此操作所需的参数**(操作数)**构成

  - 注：大多数指令不包含操作数，指令参数均存放在操作数栈中
  - 操作数长度不对齐：短小精干，但操作数运行时从字节中重建具体数据结构 （对从超过一个字节的数据）

- **字节码执行步骤**：

  - ```java
    do{
    	PC寄存器+1;
    	根据PC寄存器指示位置从字节码流中取出操作码;
    	if (字节码存在操作数) 从字节码流/操作数栈中取出操作数;
    	执行操作码定义的操作;
    } while (len(字节码流) > 0);
    ```

    

- 字节码与数据类型: <u>大多数</u>指令都包含其操作所对应的数据类型 - **非完全独立**

  - **大多数指令没有支持byte,short,char且没有任何指令支持boolean - 编译器在编译器/运行期将byte和short类型数据带符号扩展为相应的int类型数据; 将char和boolean零位扩展为相应int类型数据; 在处理这些类型数组时也会使用对应int类型字节码指令处理 -> 大多数对这些类型的数据的操作实际上都是对应的对int类型作为运算类型进行的.**

  1. 加载和存储指令
  2. 运算指令
  3. 类型转换指令
  4. 对象创建和访问指令
  5. 操作数栈管理指令
  6. 控制转移指令
  7. 方法调用和返回指令
  8. 异常处理指令
  9. 同步指令
     - **同步一段指令集序列通常由synchronizd语句块表示, JVM指令集有monitorenter和monitorexit两条指令支持该关键字语义,需要Javac编译器和Java虚拟机共同协作支持. 需保证方法中调用的每条enter都有对应的exit**

## 



# U7 - 虚拟机类加载机制

## Question:

1. 类的生命周期
   - 加载，连接（验证、准备、解析），初始化，使用，卸载
2. 类加载的过程
   - 类的生命周期
   - 加载：加载二进制字节流，存储到方法区，生成java.lang.Class对象作为方法区该类数据获取入口
   - 验证：确保Class文件中的字节流包含信息符合JVM规范全部约束要求，不会危害JVM安全
   - 准备：为类中定义的静态变量分配内存并赋予初始值
   - 解析：<u>JVM将常量池内的符号引用替换为直接引用过程</u>， *类和接口解析、字段解析、方法解析、接口方法解析*
     - 符号引用：*以一组符号来描述所引用的目标*
     - 直接引用：*可以直接指向目标的指针、相对偏移量或者间接定位到目标的句柄。*
   - 初始化: 搜集所有为类变量赋值和静态语句块中的语句，为静态变量赋值。
3. 类加载的触发条件
   1. new关键字/调用类静态方法/获取类静态属性
   2. 父类调用 - 调用类时其父类还未加载
   3. 接口调用 - 调用类时若类实现了带有默认方法的接口且接口还未被加载
   4. 反射调用 - 使用反射方法对类型进行反射调用
4. 比较两个类是否相等
   - 两个类由同一个类加载器加载的前提下比较。
5. 双亲委派机制
   1. 模型： 启动类加载器 -> 扩展类加载器 -> 应用类加载器 -> 自定义类加载器
   2. 过程：
   3. 作用：使得Java中的类随它的类加载器一起具备了层级关系（Object类，用户自己写的可以编译但永远得不到执行）
   4. 破坏：重写ClassLoade中的loadClass()方法



## 7.1 类加载概述

- **Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型**
- 类型的加载、连接、初始化均在运行期进行，提供了扩展性和灵活性。



## 7.2 类加载时机 - 初始化

- **类加载的生命周期：加载、<u>验证、准备、解析</u>、初始化、使用、卸载。** 
  - 解析阶段可能在初始化之后再开始 - (动态绑定/晚期绑定)
- **初始化：有且只有如下六种情况 （类型没有进行过初始化）**
  1. new关键字实例化对象、读取/设置静态字段(不包括被final修饰编译器置入常量池的静态字段)、调用一个类型的静态方法
  2. 反射调用 - java.lang.reflect包方法对类型反射调用
  3. 父类初始化 - 初始化类时其父类还没初始化需先触发父类初始化
  4. 接口定义了默认方法，若有接口的实现类初始化，则接口需先被初始化。
  5. 主类初始化 - 用户需指定一个要执行的主类(含有psvm方法的)，虚拟机先初始化主类
  6. *JDK7动态语言支持的初始化，MethodHandle实例* 



## 7.3 类加载的过程

### 1. 加载

1. 通过一个类的全限定名获取定义此类的二进制字节流
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
3. 内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类各种数据的访问入口。



### 2. 验证

- **确保Class文件的字节流包含的信息符合JVM规范的全部约束要求 (保证不危害虚拟机自身安全)**
- 验证阶段检验动作：
  1. 文件格式验证
  2. 元数据验证
  3. 字节码验证
  4. 符号引用验证x

### 3. 准备

- **正式为类中定义的变量（静态变量）分配内存并设置类变量初始值。**

### 4. 解析

- Java虚拟机将常量池内的符号引用替换为直接引用的过程。
  - 符号引用：*以一组符号（任何形式字面量）来描述所引用的目标*
  - 直接引用：*可以直接指向目标的指针、相对偏移量或者间接定位到目标的句柄。*

### 5. 初始化

- **初始化阶段就是执行类构造器\<clinit>方法的过程 （Java编译器自动生成物）**
  - 编译器自动搜集类中所有类变量赋值动作和静态语句块中的语句合并产生。
  - <u>不同于构造函数\<init>()，不需显式调用父类构造器，JVM会保证子类\<clinit>执行前父类已执行</u>



## 7.4 类加载器

- 将加载阶段“通过一个类的全限定名获取描述该类的二进制字节流”动作放到Java虚拟机外部实现， 让应用程序自己决定如何获取所需类。



### 1. 类与类加载器

- **对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性**，每一个类加载器都有一个独立的类名称空间。
  - 判断两个类是否相等 - <u>只有两个类是由同一个类加载器加载前提才可能。</u>



### 2. 双亲委派模型

- 虚拟机角度而言的类加载器： 
  1. **启动类加载器Bootstrap ClassLoader** - 使用C++实现，是虚拟机自身一部分
     - 负责加载存放在\<JAVA_HOME>\lib目录或被-Xbootclasspath参数指定路径存放，且能被Java虚拟机识别的类
  2. 其他所有类加载器 - 由Java语言实现，独立存在于虚拟机外部，全部继承自抽象类java.lang.ClassLoader



- Java开发人员角度而言的类加载器: 三层类加载器、双亲委派的类加载结构

  - 启动类加载器：加载存放在\<JAVA_HOME>\lib目录或者被-Xbootclasspath参数指定的路径中存放的，且能被Java虚拟机识别的类库
  - 扩展类加载器：加载\<JAVA_HOME>\lib\ext目录，或被java.ext.dirs系统变量所指定的路径中的所有类库。
    - Java系统类库的扩展机制，扩展JavaSE功能
  - 应用程序(系统)类加载器：加载用户类路径上的所有类库。
    - getSystemClassLoader()方法返回， 程序默认的类加载器。
  - 自定义类加载器，扩展。

  

  - 双亲委派模型： 展示各种类加载器之间的层次关系
    - 除顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。 (父子关系**一般不是继承而是组合**来复用父加载器中的代码)
    - 工作过程：**若一个类加载器收到了类加载请求，首先不会自己去尝试加载这个类，而是把请求委派给父类加载器去完成，最终传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求时(搜索范围没有找到所需类)，子加载器才会尝试自己去加载。** 
    - 优势: Java中的类随着它的类加载器一起具备了一种带有优先级的层次关系。且保证每个顶层类出自同一个类加载器。 - （自己编写的顶层类可以编译但永远无法执行）
  - 双亲委派模型的破坏：
    1. 基础类型调用回用户的代码 -> 调用SPI(服务提供者接口)代码  （JDBC）
       - 线程上下文类加载器，基础类型使用线程上下文加载去加载所需SPI服务代码。
    2. “热” - 代码热替换，模块热部署



# U12 - Java内存模型与线程

### 12.3 JMM 内存模型

Java内存模型：**一次编译，处处运行** - 屏蔽各种硬件和操作系统的内存访问差异，让Java程序在各种平台下都能达到一致的内存访问效果。



主内存：所有变量(不包含局部变量与方法参数)存储的位置。（对应物理硬件的内存）

工作内存：每条线程都有的独立工作内存，**保存被线程使用的变量的主内存副本。**

- 线程对变量的操作都在工作内存中进行而不能直接读写主内存数据；线程之间亦不可直接访问对方工作内存变量。（对应寄存器/高速缓存）
- **主内存与线程工作内存之间通过save和load操作进行数据交互。**



**内存间交互操作**

1. lock：作用于主内存的变量，将一个变量标识为线程独占状态

   - 对变量执行lock操作会清空工作内存此变量值，执行引擎使用该变量前需重新执行read, load来初始化变量值
2. unlock：作用于主内存变量，将一个lock变量锁释放
   - unlock之前必须将变量同步回主内存 (store, write)
3. read：将变量值从主内存传输到线程的工作内存中
4. load：将read操作得到的变量值置入工作内存变量副本中
5. use：将工作内存变量值传递给执行引擎 - 虚拟机遇到需使用变量值的字节码指令时调用
6. assign：将一个从执行引擎接受的值赋给工作内存变量 - 虚拟机遇到给变量赋值的字节码指令时调用
7. store：将工作内存一个变量值传递给主内存
   - read&load,  store&write必须成对出现
8. write：将store获取的值赋予主内存变量



volatile保障策略：

1. 线程对变量的use操作与read，load操作相关联且必须连续一起出现：  **保障线程每次使用变量必须从主内存获取最新值**
2. 线程对变量的assign操作与store，write相关联且必须连续一起出现：  **保障线程每次修改V后立刻同步回主内存中**
3. 线程对变量操作执行顺序： read/write 严格遵循use/assign动作的执行顺序。   **保障volatile修饰变量不会被指令重排序优化**



#### *volatile关键字*

作用：对应于属性的修饰符 - **使变量具有内存可见性以及防止指令重排序**
- 内存可见性：一条线程修改了该变量的值，新值对于其他线程可以立即得知（只保证内存可见性） (传统变量需向内存回写，只有回写完成后再进行读取操作新值才可见)
  - <u>若不符如下两个条件，仍需添加同步锁保证原子性。</u>
  - **运算结果不依赖变量的当前值/能确保只有单一线程修改变量值**
    - eg. 若有多个线程对一个voliatil执行自增操作，自增操作包括取值，++，赋值。 volatile只保证取值操作取到的为最新值于操作栈顶
  - **变量不需要与其他状态变量共同参与不变约束**
- 禁止指令重排序：
  - 指令重排序：仅保证方法执行过程依赖赋值结果地方获取正确结果，**不保证变量赋值操作的顺序(汇编代码)与程序代码执行顺序一致。** - *多线程环境下若多个处理器访问同一块内存，为加快执行顺序处理器允许多条指令不按规定顺序地分开送往各个处理器响应单元进行处理，加快指令执行速度，但分开的指令运行结果相同*
  - 实现方法：添加内存屏障 - **被volatile修饰的变量，在赋值后多执行了一条添加内存屏障操作，使重排序时不能把后面的指令重排序到内存屏障之前的位置。**   保障后面指令使用时内存屏障之前的操作已经正确赋值完成？

#### *synchronized关键字执行流程*

1. synchronized关键字经javac编译后会在同步块前后形成两个字节码指令`monitorenter`,`monitorexit`。均关联一个reference类型参数执行加锁解锁对象。
2. 执行monitorenter指令时首先尝试获取对象锁，若没被锁定或当前线程已经持有锁则锁计数器+1，执行monitorexit时所计数器-1. 计数器=0时锁被释放可被其他线程获取。
3. 若执行monitorenter指令获取对象锁失败则当前阻塞等待直至所计数器为0.

## 12.4 线程实现

1. 内核线程实现：由操作系统内核支持的线程，由内核完成线程切换
2.  用户线程实现：不是内核线程都可以被认为此
3.  内核线程与用户线程一起使用的实现方式





- 线程调度方式：
  1. 协同式线程调度：线程执行时间由线程自身控制
  2. **抢占式线程调度：线程由系统分配执行时间，线程切换不由线程自身决定**



- Java线程状态：

  1. 新建：创建线程后尚未运行
  2. 运行：Running/Ready状态线程
  3. 无限期等待：没有设置Timeout参数的  wait/join方法
  4. 限期等待： 设置Timeout参数的 wait/join方法
  5. 阻塞: 等待获取排他锁
  6. 结束

  



# U13 - 线程安全与锁优化

## 1. 线程安全

线程安全：多线程环境下访问对象时，调用者不需进行额外的同步及其他协调操作，使得调用这个对象都能获得正确的结果。

实现方法

1. 互斥同步：*互斥实现同步*
   - **同步：多个线程并发访问共享数据时，保证共享数据同一时刻只被一条线程使用。**
   - 实现方法:  1. synchronized关键字
     - *需要指明一个referenct类型参数作为锁定和解锁的对象*。
     - 方法中：静态方法-CLass对象； 非静态方法-对象实例
     - 同步代码块：()中指明的同步监视器
     - 重量级锁-阻塞/唤醒线程需借助操作系统帮忙 - **用户态到和心态的转换**
   - 实现方法：2. JUC包的Lock接口 try - finally  - **类库层面实现同步**
     - 优势: 等待可中断、可实现公平锁、锁可绑定多个条件
2. 非阻塞同步：基于冲突检测的乐观并发策略
   - 可借助UnSafe包下的CAS操作来实现
3. 无同步方案：不涉及共享数据的方法
   1. 可重入代码：代码执行的任何时间中断它，转而去执行另外一段代码（控制权返回后原程序不会出现任何错误且不会对结果有所影响）
   2. 线程本地存储ThreadLocal：*检查共享数据代码是否能保证在同一个线程中执行，若能，就可把共享数据的可见范围限制于同一个线程内。*





## 2. 锁优化

https://baijiahao.baidu.com/s?id=1717781876275288385&wfr=spider&for=pc

锁优化的目的：为实现高效并发效果，使得线程之间更高效地共享数据并解决竞争问题。



1. 自旋锁与自适应自旋： 不进行线程挂起与恢复 - **让等待线程“自旋”但不放弃处理器执行时间，检查持有锁的线程是否很快释放锁。**
   - 避免线程切换的开销，适用于锁被占用时间较短情况
     - -XX: +UseSpinning开启自旋锁，默认即开启
     - -XX: PreBlockSpin修改自旋重试次数，**默认值10次**
   - 自适应自旋: **由前一个在同一个锁上自选时间及锁拥有者状态决定自旋时间。**
   
2. 锁清除：虚拟机即时编译器运行时，对一些代码要求同步，**但对被检测到不可能存在共享数据竞争的锁进行消除。**
   
   - 判定依据: 逃逸分析的数据支持？
   
3. 锁粗化：若虚拟机探测到有一串零碎操作对同一个对象加锁，就会把加锁同步的范围扩展到整个操作序列外部。
   
   - eg. StringBuilder中 频繁调用apped锁粗化
   
4. 轻量级锁：没有多线程竞争的前提下，减少传统的重量级锁使用产生的性能损耗。（利用CAS操作）
   - 相对于操作系统互斥量实现的传统锁 - 重量级锁而言的
   - 工作流程： (若存在两条以上线程竞争同一个锁就会膨胀为重量级锁) 
     - 代码即将进入同步块时，若此同步对象没有被锁定(锁标志位01)，虚拟机首先在当前线程的**栈帧中创建“锁记录空间Lock Record”存储锁对象目前的Mark Word拷贝**，
     - 加锁操作使用一次CAS操作将对象的MarkWord更新为指向锁记录Lock Record的指针，cas成功则当前线程持有该锁标志位置00；失败时首先检查对象Mark Word是否指向当前线程的栈帧，若是则当前线程直接进入同步块执行即可；若存在两条以上线程争用同一个锁则锁膨胀为重量级锁。
     - 解锁也是使用CAS实现将栈帧中赋值的Mark Word替换Mark Word （**若替换失败说明有其他线程尝试过获取该锁 - Monitor，需在释放锁的过程唤醒被挂起线程）**
   - 依据: 大部分锁在同步周期不存在竞争，通过CAS操作避免互斥量开销。
   
5. 偏向锁：消除数据在无竞争状况下的同步原语，进一步提高程序运行性能。（CAS都不用了）
   - 启用参数: -XX: +/-UseBiasedLocking
   - 工作流程：偏袒第一个获取锁的线程
     - 锁对象第一次被线程获取时虚拟机将锁标志位设置为01偏向模式1，CAS操作记录获取的线程ID：成功则持有偏向锁的线程进入这个锁相关同步块时不再需任何同步操作；一旦另一个线程尝试获取锁则结束偏向模式，恢复到未锁定/轻量级状态，按照轻量级锁流程去执行。
   
6. 重量级锁：需对调用线程进行阻塞唤醒操作的锁。

   - Montor：Owner锁持有者；WaitSet等待队列；EntrySet阻塞队列。同时也存储了非加锁状态下对象的Mark Word

   - 与轻量级锁的转换：轻量级锁遇到竞争条件时会进行锁膨胀。 为Object对象申请Montior锁，对象Mark Word指向Monitor地址，更改其Owner，WaitSet，EntrySet

![image-20220411194326140](C:\Users\86137\AppData\Roaming\Typora\typora-user-images\image-20220411194326140.png)