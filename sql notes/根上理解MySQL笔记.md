>  一些与数据库有关的一些术语

1. 关系：一个关系对应一张表 (一张二维表)
2. 元组: 表中的一行即为一个元组 (记录或行)
3. 属性：表中的一列即为一个属性 (列)
4. 码(key)：主键，可以唯一确定一个元组
5. 域：一组具有相同数据类型的值的集合，属性的取值来自于某个域(性别：男/女)
6. 分量: 元组中的一个属性值 (一条记录中的一个列值)
7. 关系模式：对关系的描述 - 关系名(属性1，属性2，... ,属性n) (表头)



1. 码：设K为表中一个属性/属性组，若除K外所有属性都**完全函数依赖**于K，则K即为码/候选码
2. 函数依赖：若表中属性x值确定，则y值确定，那么可以成为y函数依赖x：**x -> y | y=f(x)**
   1. 完全函数依赖：x -> y 且 x任意真子集x'不满足 x' -> y  <u>**x F-> y**</u>
   2. 传递函数依赖：x -> y, y -> z : x -> z   <u>**x T-> z**</u>
   3. 部分函数依赖：x -> y且并非完全依赖  **<u>x P-> y</u>**
3. 元组：行
4. 属性：列



1NF: 数据库属性不可拆分

2NF: 基于1NF，消除非主属性对码的部分函数依赖

3NF: 基于2NF，消除非主属性对码的传递函数依赖

# U3-字符集&比较规则

- 从发送请求到接收结果过程中发生的字符集转换：

客户端使用操作系统的字符集编码请求字符串，向服务器发送的是经过编码的一个字节串。
服务器将客户端发送来的字节串采用 character_set_client 代表的字符集进行解码，将解码后的字符
串再按照 character_set_connection 代表的字符集进行编码。
如果 character_set_connection 代表的字符集和具体操作的列使用的字符集一致，则直接进行相应操
作，否则的话需要将请求中的字符串从 character_set_connection 代表的字符集转换为具体操作的列
使用的字符集之后再进行操作。
将从某个列获取到的字节串从该列使用的字符集转换为 character_set_results 代表的字符集后发送到
客户端。
客户端使用操作系统的字符集解析收到的结果集字节串。
在这个过程中各个系统变量的含义如下：
|系统变量|描述| |:--:|:--:| | character_set_client |服务器解码请求时使用的字符集|
| character_set_connection |服务器处理请求时会把请求字符串从 character_set_client 转为
character_set_connection | | character_set_results |服务器向客户端返回数据时使用的字符集|
一般情况下要使用保持这三个变量的值和客户端使用的字符集相同。



# U4 - InnoDB行格式



- 真实数据在不同存储引擎中存放存放的格式一般是不同的(Memory甚至不用磁盘来存储)

- InnoDB：将表中数据存储到磁盘上的存储引擎
- InnoDB存取方式（页）：**将数据划分成若干页，以页作为磁盘和内存之间交互的基本单位，InnoDB中页的大小一般未16KB**

## 4.3 InnoDB行格式

- 行格式: 记录在磁盘中的存放方式。
  - Compact
  - Redundant
  - Dynamic
  - Compressed

### 1. 行格式使用语法 ROW_FORMAT

1. 在创建表时指定行格式
   - **CREATE TABLE 表名 (列的信息) ROW_FORMAT=行格式名称**
2. 在修改表时使用行格式
   - **ALTER TABLE 表名 ROW_FORMAT=行格式名称**

### 2. COMPACT行格式

1. 记录的额外信息：

     ![image-20211030085113102](C:\Users\86137\AppData\Roaming\Typora\typora-user-images\image-20211030085113102.png)

   1. 变长字段长度列表：存放可变长度字段 *VARCHAR(M)*
      - 在 Compact 行格式中，把**所有变长字段的真实数据占用的字节长度都存放在记录的开头部位，从而形成一个变长字段长度列表，*各变长字段数据占用的字节数按照列的顺序逆序存放*** （列数靠后的存储在前）
      - W-字符集中表示一个字符需要的最多字节数
      - M-某种边长类型能存储的最多字符
      - L-实际存储的字符串占用的字节数
      - 可变字段长度列表使用字节数判断：**若M*W(可变字段能存储的最大字节数)>255且L>127 ，则使用2个字节；否则使用1个字节**。
      - 注:*对于 CHAR(M) 类型的列来说，当列采用的是定长字符集时，该列占用的字节数不会被加到变长字段长度列表，而如果采用变长字符集时，该列占用的字节数也会被加到变长字段长度列表。*
   2. NULL值列表：存放可为null值中的null字段
      - **将每个允许存储NULL的列（不被NOT NULL修饰的）对应一个二进制位，二进制位按照列的顺序逆序排列，1-代表该列值为NULL，0-非NULL**
      - NULL值列表必须使用整数个字节的位来表示（高位补0）
   3. 记录头信息：描述记录信息 5个字节位

2. 记录的真实数据
   - 记录中每列的实际值
   - 三个隐藏列：DB_ROW_ID(row_id);  DB_TRX_ID(transcation_id); DB_ROLL_PTR(回滚指针)
     - **InnoDB存储引擎会为每条记录都添加 transaction_id和 roll_pointer 这两个列，但是 row_id 是可选的（在没有自定义主键以及Unique键的情况下才会添加该列）**



- 行数据规范 - 一个行中的所有列（不包括隐藏
  列和记录头信息）占用的字节长度加起来不能超过65535个字节！ (*根据具体字符集不同所能存储的最大*M值不同)
- **行溢出：当记录中的数据太多，当前页放不下的时候，会把多余的数据存储到其他页中，这种现象称为 行溢出** 。
- 行溢出数据：对于占用存储空间非常大的列，在 记录的真实数据 处只会存储该列的一部分数据，把剩余的数据分散存储在几个其他的页中，*然后 记录的真实数据 处用20个字节存储指向这些页的地址*
- 行溢出的临界点：对于只有单列表，一条记录最小存储数据值计算公式如下：
  - **136 + 2 * (27 + n) > 16KB**
  - 136：分页中存储额外信息
  - 27： 每个记录需要的额外信息
  - 2： MySQL规定一页中至少存储两行记录



- Dynamic： 行溢出时在真实数据处只会存取溢出页地址(不存储部分真实数据前768字节)
- Compressed：行格式会采用压缩算法对页面进行压缩，节省空间。



# U5 - InnoDB页结构

## 5.3 记录在页中的存储

- **不论我们怎么对页中的记录做增删改操作，InnoDB始终会维护一条记录的单链表，链表中的各个节点是按照主键值由小到大的顺序连接起来的。**

- delete_mask:  表示当前记录是否被删除 - 0未删除，1已删除
  
  - 被删除的记录之所以不立即从磁盘上移除（性能损耗），**所有被删除掉的记录都会组成一个所谓的 *垃圾链表*** ，**在这个链表中的记录占用的空间称之为所谓的 *可重用空间*** ，之后如果有新记录插入到表中的话，可能把这些被删除的记录占用的存储空间覆盖掉。
  
- n_owned : 每个分组中主键序号最大元素记录存储的该分组记录条数

- record_type : 记录类型 ： 0-普通用户记录  2：inimum   3：supremum   1:目录项记录

- heap_no : 当前记录在本页中的位置 ，按主键比较，2开始
  
  - 两条按主键排序的记录：最小记录infimum-0，最大记录supremum-1
  
- next_record : 当前记录的真实数据到下一条记录的真实数据的地址偏移量 **（记录按照主键从小到大的顺序形成了一个单链表）**
  - 下一条记录：按主键顺序排序的下一条记录  （heap_no : 0-2-3-4-..-1）
  - 当数据页中存在多条被删除掉的记录时，这些记录的next_record属性将会把这些被删除掉的记录组成一个垃圾链表，以备之后重用这部分存储空间。



## 5.4 页目录 Page-Directory

- 对应查询字典/书籍 - 先找目录再查数据
  1. 将所有正常的记录（包括最大和最小记录，不包括标记为已删除的记录）划分为几个组。
  2. 每个组的最后一条记录（也就是组内最大的那条记录）的头信息中的 n_owned 属性表示该记录拥有多少条记录，也就是该组内共有几条记录。
     - 最小记录所在分组只能有1条记录
     - 最大记录所在分组可有1~8条记录
     - 其余分组可有4~8条记录
  3. **将每个组的最后一条记录的地址偏移量单独提取出来按顺序存储到<u>靠近 页 的尾部</u>的地方，这个地方就是所谓的 Page Directory ，也就是 页目录 （此时应该返回头看看页面各个部分的图）。页面目录中的这些地址偏移量被称为 槽 （英文名： Slot ），所以这个页面目录就是由 槽 组成的。**





- **在一个数据页中查找指定主键值记录的步骤：**
  1. <u>**通过二分法确定该记录所在的槽，并找到该槽中主键值最小的那条记录（上一槽的next）**</u>
  2. <u>**遍历该槽的每个记录，查找被查询记录。**</u>



## 5.5 页面头部 Page-Header

- 针对 数据页 存储记录的各种状态信息 - 占用固定38字节

![image-20211030095325644](C:\Users\86137\AppData\Roaming\Typora\typora-user-images\image-20211030095325644.png)

- PAGE_DIRECTION : 最后一条插入记录位置方向相较于上一条记录的位置：（主键值比较，左右）
- PAGE_N_DIRECTION : 连续插入方向相同时统计相同数量



## 5.6 文件头部 - File Healder

- 针对数据页整体通用信息的记录 （页编号，下一页编号）

![image-20211030095935070](C:\Users\86137\AppData\Roaming\Typora\typora-user-images\image-20211030095935070.png)

- FIL_PAGE_SPACE_OR_CHKSUM :  校验和： 用某种算法计算的较短的值来表示一个较长的字节串 (先比较校验和)
- FIL_PAGE_OFFSET : 页的单独页号 - 唯一定位一个页
- FIL_PAGE_TYPE : 代表当前页类型



## 5.7 File Trailer

- InnoDB将数据存储到磁盘上的过程需以页为单位将数据加载到内存中处理。 若页中数据在内存中被修改，将修改数据同步到磁盘中时可能发生异常使页数据同步不完全 - 页面尾部的File Trailer（8字节）处理

- 前4个字节：页的校验和 - 同步过程会使校验和更改，File Header中的首先被修改， 完全写完时File Trailer页会被写完
  - **页面头部File Header中的校验和与页面尾部File Trailer中的校验和比较 - 不相同则同步过程出错**
- 后4个字节:  页面最后被修改对应的日志序列位置LSN - 检验页的完整性



# U6 - B+树索引

## *Question*

- B+树: **B+树每层节点按照索引列值由小到大排序组成双向链表，每页记录按照索引列由小到大形成单链表**
  - 内节点: 每页索引列的最小值以及对应页号  
  - 叶子节点：存储完整的列信息

1. 使用B+树的原因:  B+树更矮胖，树高更低，查询效率更高 (磁盘索引次数少?)
   - B+树仅在叶子节点存储用户记录，其他节点存储目录项记录(索引列与对应页号)； 
   - B树在所有节点存储用户记录。 
   - 哈希索引: 不能进行范围搜索，不支持排序，树深度比较大（磁盘扫描次数多）
2. 聚簇索引与二级索引区别： 
   - 聚簇索引:  以主键作为页和记录的排序规则，叶子节点存储表中所有列信息
   - 二级索引:  以指定索引列作为页和记录的排序规则，叶子节点存储索引列以及主键
3. 查询用不到索引的情况：
   1. 使用索引比全表扫描还要慢时
   2. 对字符串的模糊查询以%开头
   3. 联合索引没有用到最左索引列
   4. where中索引列不以单独列名存在而是存在于一个表达式中





- M阶B-树中的每个结点儿子个数 n 的取值范围为 ⌈M/2⌉ ≤ n ≤ M，而在 M阶B+树中每个结点中儿子个数 n 的取值范围为：⌈M/2⌉ ≤ n ≤ M。

- B树： 查询关键字分布在整个树种，任何一个/一组关键字只存在一个节点中。
  - 插入：插入后若多余M-1，中间元素上移，根据B树性质做分裂、旋转
    - 左旋：将右叶子节点值移植父节点，将父节点值移植空的左子节点
    - 右旋：左节点 -> 父节点； 父节点 -> 右节点
  - 删除：删除后根据性质旋转





![img](http://data.biancheng.net/uploads/allimg/171024/2-1G0241402324A.png)

- B+树：M阶B+树，内节点每个节点的关键字个数=儿子个数，保存关键字与索引，关键字为对应儿子的最大/最小值；所有关键字与对应数据保存在叶子节点中，叶子节点排序构成双向链表。
  - 两个指针：指向根节点的指针与指向叶子节点关键字最大/最小的指针。
  - 插入：
    - 被插入节点关键字数目<M，直接插入
    - =M，将该节点分裂为两个节点，一个包含比中间节点大，一个包含比中间节点小，将中间节点关键字上移至父节点（若父节点关键字个数=M继续对父节点分裂）
    - 若插入节点关键字小于原有最小节点，则需将对应父节点最小值索引更改。
  - 删除：
    - 删除的是最小节点，则需将父节点对应最小节点索引更新
    - 删除后若倒置当前节点关键字个数<M/2，可向兄弟节点借一个多余关键字；若兄弟节点没有多余关键字，需与兄弟节点合并。
- Hash索引：进行Hash运算后的Hash值（Hash大小关系与元素大小关系不同）比较，只能用于等值查询，不能用于范围查询。

- 对比
  - b+树中间节点不保存数据，数据页能容纳更多节点元素，更矮胖
  - b+树查询效率更稳定，稳定查询到叶子节点；B树则不一定
  - 范围查找，b+树遍历叶子节点链表；b树需要重复中序遍历。
  - Hash索引只能等值查询，不支持范围查询；Hash一般需将数据一次性全部加载到内存中查询，数据量较大时不允许。



- 通常查找： 从第一个页沿着双向链表查找，每个页中根据查询主键还是值使用二分或者遍历。

## 6.2 索引

- 原则：下一个数据页中的用户记录主键值必须大于上一个页 
- 页分裂: 当页中无空闲区时进行页分裂，遵循上述原则
- 每个页对应一个目录项
  - key：页用户记录最小主键值
  - page_no : 对应的页号



### 6.2.2 InnoDB索引方案 - 数据即索引，索引即数据

- **复用存储用户记录的数据页存储目录项 - 目录项记录 record_type=1**

###### 目录项记录与用户记录的不同点：

1. 目录项记录record_type为1，普通用户记录为0
2. 目录项记录只有主键值和页编号两个列，没有其他列与隐藏列
3. 目录项记录的min_rec_mask属性最小主键记录设置为1



- 当目录项记录页满时，可再开辟一页存储目录项； 当目录项记录页较多时，可开辟一更高级的页 - **存储目录项记录的页**
  - 存储目录项记录的页存储一个目录项页中最小主键记录与对应页号

![image-20211030112015539](C:\Users\86137\AppData\Roaming\Typora\typora-user-images\image-20211030112015539.png)





- 叶子节点 - 实际存放的用户记录
- 非叶子节点 - 目录项页与存放目录项页的节点

#### 6.2.2.1 聚簇索引

- InnoDB存储引擎默认的数据存储方式 - 索引即数据，数据即索引

1. 使用主键值的大小进行记录和页排序
   - 页内记录按逐渐大小拍成单向链表
   - 存放用户记录的页也是根据用户记录的主键大小拍成双向链表 （无论层次）
2. B+树的叶子节点存储完整用户记录



#### 6.2.2.2 二级索引

- 针对非主键的索引，按一定排序规则建立B+树

![image-20211030114927680](C:\Users\86137\AppData\Roaming\Typora\typora-user-images\image-20211030114927680.png)

- 区别于聚簇索引
  1. B+树叶子节点存储的不是完整用户记录，而是 **索引列+主键**两列值
  2. 目录项记录是**索引列+页号**的搭配



- 二级含义： **查找到用户记录后根据找到的主键列根据主键值再去进行聚簇索引查找一遍完整的用户记录 - 回表。**
  - 避免过度空间的占用



##### 联合索引

- 本质上亦为二级索引

- 为多个列的大小作为排序规则建立索引 (c2,c3)
  - c2排序，c2相同时以c3排序



### 6.2.3 InnoDB B+树索引注意事项

- **根节点页面不变 - B+树索引根节点不会移动**  （**InnoDB需要某个索引时就会从固定地方(数据字典)去除建立的根节点页号访问索引**）

  1. 为某个B+树建立索引时，都会为索引创建一个根节点页面，初始无数据时根节点页面也没有任何记录

  2. 插入用户记录时将用户记录存储到根节点页面中

  3. **当根节点页面可用空间用完时，将根节点所有记录复制到一个新分配的页(a), 对新页执行页分裂操作得到另一个新页(b)。新插入的记录根据对应索引项大小被分配到a/b中，跟页面升级为存储目录项记录的页。**



- 内节点中目录项记录的唯一性
  - 问题引入： 内节点若只有二级字段与页号的话，二级字段值相同则新插入数据会不知所措。
  - **需保证B+树同一层内节点的目录项记录除页号字段外唯一**  
  - 措施：二级索引内节点目录项记录内容由三部分构成： **索引列的值，主键值，页号**



- 一个页面至少存储两条记录 - 保证B+树的索引效率





### 6.2.4 MyISAM索引方案简介

- 索引非数据 - 索引与数据分开存储
  - *按照记录的插入顺序*将记录单独存储在一个文件中 - **数据文件**。
    - 包含行号，记录头，主键值，列数据值
  - 将索引信息另外存储到另一个文件 - **索引文件**， 单独为表的主键创建一个索引，索引的叶子节点存储的是**主键值与行号**
    - 先通过索引找行号，再通过行号找数据
    - **相当于MyISAM中建立的索引都是二级索引** ， 先根据索引找行号，再根据行号找数据
  - 索引中定长字符存储行号，非定长字符存储存储记录在数据文件中的地址偏移量。 - 快速回表。



### 6.2.5 创建索引

- InnoDB与MyISAM会自动为主键或声明为UNIQUE的列建立B+树索引



- 创建其他列的索引
  1. 建表时建立：  表尾部声明：`[key|index] 索引名 (需要被索引的单个/多个列） `
  2. 修改时增加： `alter table 表名 add [index|key] 索引名 (需被索引的单个/多个列)`
  3. 删除 : `alter table 表名 drop [index|key] 索引名`





## B+树总结

1. 每个索引对应一个B+树，B+树最末一层**叶子节点存储为用户记录，其余内节点存储目录项记录**
2. InnoDB为主键列建立聚簇索引，其叶子节点包含所有完整用户记录
3. 二级索引由用户根据列自己建立，**用户记录存放索引列+主键组**，可再通过回表查询聚簇索引得到完整用户记录。
4. **B+树每层节点按照索引列值由小到大排序组成双向链表，每页记录按照索引列由小到大形成单链表**，联合索引则先按联合索引前边的列排序，相等则按照后面的列排序
   - 建立索引时指定的排序规则 `KEY idx_name_birthday_phone (name, birthday, phone_number)`。





# U7 - B+树索引使用

## Question

1. 最左匹配原则：最左优先，以最左边为起点任何连续索引都可以匹配。遇到范围查询时停止索引。

   - eg.以a,b,c列建立索引

   1. 全值匹配查询 - 查询优化器优化
   2. 匹配左边的列 - a / a,b / a,b,c
   3. 匹配列前缀 - a like 'ff%'
   4. 匹配范围值 - 使用索引至第一个范围值
   5. 排序 - order by的顺序符合建立索引顺序







## 7.1 索引代价

- 空间：数据页空间占用
- 时间：增删改 -> 记录移位、页面分裂、页面回收以维护节点和记录排序





## 7.2 索引适用条件

基于: **<u>联合索引则先按联合索引前边的列排序，相等则按照后面的列排序</u>**

```mysql
KEY idx_name_birthday_phone (name, birthday, phone_number)
```



- 全值匹配 - 搜索条件的列和索引列一致：按照建立索引时指定排序规则排序，**查询优化器->不受where影响**
- 匹配左列 - **搜索语句必需包含索引列中最左边的列** 
  - where birthday = ... 无法使用索引 （索引由左到右，**先name**再birthday再phone_number）
- 匹配列前缀 - 对于字符串类型索引字段（name），只匹配其前缀也可使用索引: 由字符串比较规则所决定
  - where name like 'Av%' 
- 匹配范围值：若对多个列进行范围查找时，只有对索引最左边列进行范围查找时才会用到索引
  - where name between ... and birthday between ... ： birthday不会使用索引 - birthday在查找到的name中不是顺序的
- 精确匹配某一列并范围匹配另一列：`name = ... and birthday between ...`
- 排序：使用索引列排序避免 *文件排序(磁盘上的排序方法)* 
  - **排序使用索引需注意如下几种情况：**
  - order by后的顺序需根据索引列顺序给出
  - 各个排序列顺序一致 只能是ASC/DESC之一 （高效使用索引）
  - 排序列不应包含复杂表达式 `(UPPER(name))`
  - 排序列不应包含非索引列
- 分组：类似于排序



## 7.3 回表代价

```mysql
select * from preson_info where name between ... ;
```

- 顺序I/O :  二级索引使用 - 查询到的name在磁盘记录中顺序存储，较集中地分布于几个数据页中
- 随机I/O :  通过二级索引回表时 - 通过name查询到的id在聚簇索引中并不顺序，可能需要查询多个数据页。

- **需要回表的记录越多，二级索引的性能越低。**



**查询优化器** - 根据具体情况选择使用**二级索引+回表**还是**全表扫描(聚簇索引)**

- LIMIT语句一般倾向于使用二级索引+回表



**覆盖索引**： 查询列中只包含索引列 避免回表 - 不鼓励使用来进行查询结果。





## 7.4 索引创建原则

1. 只为用于搜索、排序、分组的列建立索引
   - where, on, order/group by
2. 考虑列的基数（某一列中不重复数据的个数）
   - 记录行数一定的情况下，*列的基数越大则列中的值越分散；列的基数越小则列的值越集中*
   - **最好为列的基数大的列建立索引**，列基数小重复度高回表率大。
3. 索引列的类型尽量小（列类型数据范围大小） - 查询操作快，索引占用存储空间少
4. **索引字符串值的前缀** - 对字符串列的前几位而非全部建立索引 **name(10)**
   - `KEY idx_name_birthday_phone (name(10), birthday, phone)`
   - 优点：节约空间，减少比较时间
   - 缺点：排序索引列时因不包含列完整信息*需文件排序*。
5. 让索引列在比较表达式中单独出现 - **若索引列以表达式形式存在可能用不到索引。**
   - `where i < 10/2` 符合条件-单独出现
   - `where i * 2 < 10` **存储引擎会依次遍历所有记录，计算该表达式的值是否小于10；而不会使用索引。**
6. 主键插入顺序 - **主键 AUTO_INCREMENT属性**
   - 不按序插入会造成页面分裂和记录移位 - 性能损耗
7. 避免冗余重复索引
8. 尽量使用**覆盖索引**避免回表带来性能





# U8 - MySQL数据目录



## 8.1 数据库与文件系统

- 文件系统：操作系统管理磁盘的系统
- **InnoDB, MyISAM将表存储到文件系统**
  - 读取数据：从文件系统将数据读取出来返回
  - 写入数据：存储引擎将数据写回文件系统



## 8.2 MySQL数据目录

数据目录: MySQL服务器启动时到文件系统目录**加载的文件**，运行时产生数据的**存储文件**。

- `show variables like "datadir"`显式数据目录本地地址



### 8.3 数据目录结构

### 8.3.1 数据库在文件系统中的表示

- **每个数据库均对应数据目录下的一个子目录(文件夹)**
- 创建数据库的过程：
  1. 数据目录下创建数据库同名子目录
  2. 子目录下创建一个名为db.opt文件，包含数据库各种属性（字符集、比较规则。。。）

### 8.3.2 表在文件系统中的表示

1. 表结构定义 - 表名.frm **MySQL8.0取消该结构，并入到了.ibd文件中**
   - 表的名称、列数、列的数据类型、约束索引、字符集。。。
2. 表中数据 - .ibd 存放数据和索引



- **InnoDB存储表数据** - 表空间/文件空间
  - 抽象概念，对应文件系统上一个或多个真实文件，可划分多个页。**表数据就存放在某个表空间下的某些页中**
  - 系统表空间：对应文件系统上一个或多个实际文件 - ibdata1
  - 独立表空间：InnoDB为每个表建立一个独立表空间，在该表对应数据库子目录下创建该文件，与表名相同， .ibd
    - **通过修改innodb_file_per_table控制使用0-系统/1-独立表空间来存储**
    - **转移表至其他表空间：alter table 表名 TABLESPACE innodb_file_per_table**
- MyISAM: 没有表空间概念，表数据都存放到对应数据库子目录下
- 视图： 只存储其结构，对应数据库下的 视图名.frm文件





## 8.4 文件系统对数据库的影响

1. 数据库名称、表名不得超过文件系统允许最长值
2. 特殊字符 - 避免名称出现特殊字符而文件系统不支持
   - **MySQL将数据库名和表名中所有数字和拉丁字母外所有字符映射成<u>@+编码值</u>的形式作为名称**
3. 文件长度受文件系统最大长度限制



## 8.5 MySQL系统数据库

1. mysql： 存储MySQL用户账户和权限，存储过程和事件的定义信息，运行过程产生的日志信息，帮助信息
2. information_schema：保存MySQL服务器维护的所有其他数据库信息 - 元数据（表，视图，触发器，列，索引。。）
3. performation_schema：保存MySQL服务器运行过程的一些状态信息（执行语句，花费时长） - 性能监控
4. sys：通过视图形式把前两个数据库结合起来，更方便地了解MySQL服务器性能信息



# U9 - InnoDB表空间 （简）

## 9.2 独立表空间

### 1. 区

- 概念：表空间被划分为许多连续的区 ，每个区默认由64个页组成，每256个区划分为一组，每个组的最开始的几个页面类型是固定的用来记录本组区属性信息。
- 减少随机I/O: **一个区就是在物理位置上连续的64个页。**在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照 区 为单位分配

### 2. 段

- 概念：一个索引会生成2个段
  1. 叶子节点段 - 叶子节点区集合
  2. 非叶子节点段存放 - 非叶子节点区集合
- 作用：提高范围扫描的的效率
- 段分配空间策略:  (碎片区：碎片区直属于表空间，并不属于任何一个段)
  - 在刚开始向表中插入数据的时候，段是从某个碎片区以单个页面为单位来分配存储空间的。
  - 当某个段已经占用了32个碎片区页面之后，就会以完整的区为单位来分配存储空间。



# U10 - 单表访问方法

- MySQL执行查询语句的方法称为**访问方法或者访问类型**

## 1. all

- 全表扫描，直接扫描聚簇索引

## 2. const

- 主键索引或者唯一二级索引

## 3. ref

- 普通二级索引与常数**等值比较**（含null）

```mysql
SELECT * FROM single_table WHERE key_part1 = 'god like'; 
 SELECT * FROM single_table WHERE key_part1 = 'god like' AND key_part2 = 'legendary'; 
 SELECT * FROM single_table WHERE key_part1 = 'god like' AND key_part2 = 'legendary'
AND key_part3 = 'penta kill';
```



## 4. ref_or_null

- 二级索引既等值常数比较又比较null值

```mysql
SELECT * FROM single_demo WHERE key1 = 'abc' OR key1 IS NULL
```

## 5. range

- 二级索引范围查询
  - in-单点区间
  - 范围-连续范围区间

```mysql
SELECT * FROM single_table WHERE key2 IN (1438, 6328) OR (key2 >= 38 AND key2 <= 79)
```

## 6. index

*eg.二级索引包含k1,k2,k3三个列；只通过k2等值查询获取k1,k2,k3三个列的信息*

*solution: 可以直接通过遍历 idx_key_part 索引的叶子节点的记录来比较 key_part2 = 'abc' 这个条件是否成立，把匹配成功的二级索引记录的 key_part1 ,  key_part2,key_part3 列的值直接加到结果集中就行了。*

- 索引扫描：遍历二级索引记录获取查询结果

```mysql
SELECT key_part1, key_part2, key_part3 FROM single_table WHERE key_part2 = 'abc
```





## 7. 注意事项

### 7.1 查询优化器

- 优化器一般会根据表的统计数据来判断到底使用哪个条件到对应的二级索引中查询扫描的行数会更少，选择那个扫描行数较少的条件到对应的二级索引中查询

### 7.2 range使用范围

- 索引列和常数使用 = 、 <=> 、 IN 、 NOT IN 、 IS NULL 、 IS NOT NULL 、\> 、 < 、 >= 、 <= 、BETWEEN 、 != （不等于也可以写成 <> ）或者 LIKE 操作符连接起来，就可以产生一个所谓的 区间 。
  - like只会在匹配完整字符或者匹配字符串前缀时才会利用索引



- **部分搜索条件无法使用索引**
  - 在为某个索引确定范围区间的时候只需要把用不到相关索引的搜索条件替换为 TRUE 。
    - and->索引范围；or->整体true



### 7.3 索引合并 - index merge

- 特殊情况下在一次查询中使用多个二级索引的情况

#### 1. intersection合并 - 交集

- 将多个二级索引查询到的结果取交集 - 减少回表
  - 集中主键列的交集获取查询结果

```mysql
SELECT * FROM single_table WHERE key1 = 'a' AND key3 = 'b'
```

- 使用情况：

  - **ROR - 获取按主键值排序的结果集**

  1. 二级索引列等值匹配 - 多二级索引均等值匹配
  2. 主键列范围 - 二级索引等值+主键范围



#### 2. Union合并 - 并集

- 使用情况：
  1. 二级索引列等值匹配
  2. 主键列范围匹配
  3. 使用Intersection索引合并的搜索条件
     - 搜索条件的某些部分使用Intersection索引合并的方式得到主键集合与其他方式得到主键集合取并集



#### 3. sort-union合并

- 基于union合并，先获取记录并根据主键值排序，再union索引合并得到排序好的主键值。



# U11 - 连接查询原理

- 嵌套循环连接：**对于连接查询，驱动表只会被访问一遍；被驱动表要被访问n编(n为驱动表查询记录条数)**
  1. 选取驱动表，使用驱动表相关过滤条件，**选取代价最低的单表访问方法**来执行驱动表单表查询
  2. 对1中查询所得驱动表的结果集**每一条记录都分别到被驱动表中查询匹配记录**。



- 使用索引 - 驱动表与被驱动表



- 基于块的嵌套循环连接 - join buffer
  - 必要性：**在被驱动表数据较多时尽量减少被驱动表的访问次数 - 减少磁盘I/O**
  - 原: 驱动表结果集一条条匹配被驱动表的结果集（被驱动表结果集反复加载）
  - 现：被驱动表记录加载到内存时一次和多条驱动表记录匹配。（减少磁盘I/O）
  - **解决方案：join buffer** - <u>执行连接查询前申请一块固定大小内存，先把若干驱动表结果集记录封装在内</u>，然后扫描驱动表，驱动表每一条记录一次性和join buffer中的多条驱动表记录匹配。

