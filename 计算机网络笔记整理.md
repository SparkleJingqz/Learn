# U1-网络概述

## *面试题整理*

1. 浏览器输入URL后发生什么
   1. DNS解析 - 浏览器将域名从URL剥离出来，向本地DNS服务器发起请求，若本地DNS服务器没有对应缓存则需分别查询根/顶级域/权威DNS服务器（递归/迭代），得到对应的IP地址。
   2. TCP连接 - 在客户端与对应IP地址的服务器之间建立TCP连接
   3. 发起HTTP请求，获取HTTP响应
   4. 决定维持/断开连接 - 应用层/传输层
   5. 浏览器解析
2. OSI七层模型

   1. 分层
      1. 应用层：用户/应用程序与网络间的直接接口，用户能与网络进行交互，实现各种服务文件传输ftp，超文本传输协议HTTP
      2. 表示层：处理所有与数据表示及运输有关的问题，如加密解密，转换翻译 - 协商数据交换格式，压缩解压缩
      3. 会话层：不同机器上用户建立和管理会话，SSL套接字协议，RPC远程过程调用协议
      4. 传输层：主机上具有的服务 - 提供主机间进程逻辑通信；复用&分用；差错检测
      5. 网络层：将分组从源主机传送至目的主机，为网络上的主机提供通信服务。
      6. 数据链路层：在物理层基础上对网络层提供服务，封装数据报，在相邻节点间直接传送数据报，增强比特流传输。
      7. 物理层：在传输介质上实现数据链路层帧的比特流传输
   2. 作用：模块化，结构清晰，降低复杂度。
      1. 学习: 易于讨论和学习协议规范
      2. 模块化: 层级间标准接口
      3. 互联环境
      4. 复杂度: 降低复杂度，程序易于修改
      5. 下层服务：利用紧邻下层服务

## 1-5 协议层次及其模型

### 1.5.1 因特网协议栈

- 因特网协议栈由五层组成：应用层、传输层、网络层、链路层、物理层
- OSI(开放系统互连参考模型)参考模型的七层组成：应用层、**表示层、会话层**、运输层、网络层、链路层、物理层。

- 表示层与会话层留给应用程序开发者处理。

#### 1.应用层

- 应用层是网络应用程序以及它们的应用层协议存留的地方。
  - 应用层协议：HTTP(提供Web文档的请求和传送)，SMTP(提供电子邮件报文的传输)，FTP(提供两个端系统之间的文件传送)、SOCKETS安全套接字协议、DNS域名系统等

- 应用层协议分布在多个端系统上，**一个端系统中的应用程序使用协议与另一个端系统中的应用程序交换信息分组**

- 应用层的信息分组：**报文 message**

#### (2) 表示层

- 使通信的应用程序能解释交换数据的含义(数据压缩、数据加密、数据描述)

#### (3) 会话层

- 提供数据交换的界定和同步功能，**不同机器上的用户建立和管理会话**(建立检查点、回复方案)

#### 2.传输层

- 在应用程序端点之间传送应用层报文。
  1. TCP传输协议：向其应用程序提供面向连接的服务(确保传递、流量控制、拥塞控制)
  2. UDP传输协议：向其应用程序提供无连接服务(无可靠性、流量控制、拥塞控制)

- 运输层分组：**报文段 segment**

#### 3.网络层

- 网络层负责将称为数据报的网络层分组从一台主机移动到另一台主机。
- 控制子网的运行：逻辑编址、分组传输、路由选择，比如 IP、IPV6、SLIP 等等。

- 网络层分组：**数据报 datagram**

#### 4.链路层

- 网络层依靠链路层服务将分组从一个节点(主机、路由器)移动到路径上的下一个节点。
  即：在每个节点，网络层将数据报下传给链路层，链路层沿着路径将数据报传递给下一个节点，在下一个节点链路层将数据报上传给网络层。

- 网络层将受到来自每个不同链路层协议不同的服务(链路层协议)。
- **链路层分组称为帧** frame

#### 5.物理层

- 将链路层的帧中的一个个比特从一个节点移动到下一个节点(仍是链路相关协议)，且与实际传输媒介有关(铜线、光纤)

### 1.5.2 封装

- 在每一层，一个分组具有两种类型字段：首部字段和有效载荷字段(来自上一层的分组)。

1. 发送主机端，应用层报文被传送给运输层，运输层收取报文并附附加信息(运输层首部信息)被接收端运输层使用
   - 首部信息包含：允许接收端运输层向上向适当应用程序交付保温信息；差错检测位信息(判断报文比特途中是否改变)
   - **应用层报文+运输层首部信息 -> 报文段**
2. 运输层向网络层传递该报文段，网络层增加了源、目的端系统地址等网络层首部信息，生成网络层数据报
   - **报文段+网络层首部信息 -> 数据报**
3. 链路层增加其自身链路层首部信息生成链路层帧
   - **数据报+链路层首部信息 -> 帧**



# U2-应用层

## *面试题整理*

1. HTTP响应码有哪些？代表什么含义

   1. 消息
   2. 成功 - 请求已被服务器接收、理解
      - 200-OK
   3. 重定向 - 需客户端采取进一步操作才能完成（重定向，后续请求地址在本次相响应的Location域指明）
      - 301-永久重定向
      - 302-临时重定向
      - 304-对应条件get请求，请求内容与上次请求没改变
   4. 请求错误 - 客户端发生错误妨碍服务器处理
      - 400 - 语义有误，请求无法被服务器理解；请求参数有误
      - 401 - Unauthorized 请求未经授权
      - 403 - forbidden 服务器理解请求但拒绝执行
      - 404
      - 405 - Method Not Allowed 请求行中的请求方法不能用于请求响应资源，返回一个Allow头信息指示当前资源能接受的请求方法
   5. 服务器错误 - 服务器处理请求过程有错误或异常状态发生
      - 500 - 服务器内部错误
      - 501 - 服务器不支持当前请求所需某个功能

2. Forward和Redirect：

   1. 请求次数：Forward - 一次请求； Redirect - 两次请求
   2. 数据共享：Forward - 服务器内部重定向，request域在重定向过程不变；Redirect发起两次HTTP请求，使用你不同的request域
   3. 浏览器URL地址：Forward是服务器内部重定向，服务器内部发起请求然后获取响应内容，URL地址不变；Redirect客户端请求服务器，然后服务器给客户端返回302和新location，客户端重新发起HTTP请求，服务器给客户端响应location对应url地址，浏览器URL地址发生变化。

3. URI与URL

   - URL:统一资源定位符 - URI子集，带有位置信息的URI
   - URI:统一资源标志符 - 某一规则下把一个资源独一无二标识出来

4. get和post的区别：

   - 用途：获取资源；提交数据
   - 提交方式：?=&拼接到url；表单数据放到请求体 - post相对安全
   - 数据限制：URL长度限制；无限制
   - 编码：URL文本格式；二进制数据多重编码
   - 缓存：get可，post不会
   - 产生tcp数据报个数
     - get: 产生一个数据包
     - post: 两个 请求头与数据字段; firefox发一次

5. HTTP和HTTPS区别：

   - HTTPS在HTTP基础上加入SSL协议，SSL依靠证书来验证服务器身份，为浏览器和服务器间通信加密。 

   1. 端口不同： 80/443
   2. 消耗资源：HTTPS因加密处理消耗更多CPU和内存
   3. 开销：HTTPS通信需证书，向认证机构申请/付费购买

6. HTTP1.0, 1.1, 2.0关系

   - 无状态：协议对于事务处理没有记忆能力，*如果后续处理需要前面的信息，则它必须重传*

   1. Connection:close 短连接
   2. Connection:keep-alive

8. HTTP报文格式

   1. ![img](https://pic002.cnblogs.com/images/2012/426620/2012072810301161.png)
      - 请求行，首部行，空行，请求数据
   2. 响应报文：
      - 状态行，首部行，实体体

## 2-1 应用层协议原理

作用：对应用程序的通信提供服务；文件传输FTP；电子邮件SMTP；Web核心HTTP协议。

### 2.1.1 网络应用程序体系结构

应用程序体系结构由应用程序研发者设计，**规定了如何在端系统上组织该应用程序**。

两种主流体系结构

1. 客户-服务器体系结构(client-server cs)：WEB；FTP；SMTP

   - 服务器：一台总是打开的主机，服务于来自许多其他称为客户的主机的请求；服务器具有固定的周知的域名与IP地址
   - 客户机：与服务器通信使用服务器提供服务；间歇性接入网络；不与其他客户机直接通信

2. P2P体系结构(P2P)

   - 对位于数据中心的专用服务器有最小(或无)依赖；应用程序在间断连接的主机之间使用通信(对等方)；任意端系统间可直接通信；主机即可提供服务也可请求服务；可扩展性好。




## 2-2 **Web和HTTP**

### 2.1.1 HTTP概况

- 超文本传输协议(HTTP)：Web的应用层协议，Web的核心
- 实现方式：客户程序和服务器程序实现
  - 客户程序和服务器程序运行在不同的端系统，通过交换HTTP报文进行会话。
  - HTTP定义了这些报文的结构以及客户和服务器进行报文交换的方式。
- HTTP定义了Web客户向Web服务器请求Web页面的方式，以及服务器向客户传送Web页面的方式。
- HTTP使用TCP作为其支撑运输协议(客户发起一个与服务器的TCP连接，连接建立后浏览器和服务器进程可通过套接字接口访问TCP)



1. Web页面由对象组成，多数Web页面含有一个HTML基本文件和几个对象引用(1个HTML和5个JPEG)
2. HTML基本文件通过对象的URL地址引用页面的其他对象，每个URL地址由两部分组成
   - **存放对象的服务器主机名** - www.google.com
   - **对象的路径名** -  /get/user/1
3. Web浏览器实现了HTTP的客户端
4. Web服务器实现了HTTP的服务器端，用于存储Web对象，每个对象由URL寻址

### 2.2.2 非持续连接和持续连接

- 非持续连接：**每个请求响应对经过一个单独的TCP连接发送**
- 持续连接：**所有请求和响应经相同的TCP连接发送**
- HTTP默认情况下使用持续连接

连接步骤：

1. HTTP客户进程在端口号80发起一个到服务器的TCP连接  (客户和服务器上分别有一个套接字与该连接相关) 
   - 第一次握手(发送小报文段)
2. HTTP客户经其套接字向服务器发送一个HTTP请求报文(包含路径名)
3. HTTP服务器进程经其套接字接受该请求报文，从其存储器检索出对象，在一HTTP相应报文中封装对象并通过套接字想客户发送响应报文
   - 第二次握手(服务器用小TCP报文段做出确认和相应)
4. HTTP服务器进程通知TCP断开连接(直到TCP确认客户完整接受响应报文才实际断开)
   - 第三次握手：客户向服务器返回确认
5. HTTP客户接受响应报文，TCP连接关闭

- 非持续连接：先接受HTML文件得到对象引用再重复前序步骤获得所有对象(使用不同TCP连接)
- 持续连接：发送响应后保持TCP连接打开，后续请求和相应通过相同连接传送。

### 2.2.3 HTTP报文格式

#### 1- HTTP请求报文

![img](https://pic002.cnblogs.com/images/2012/426620/2012072810301161.png)


```http
GET /article/ae97a6469d2591fafd461dd4.html HTTP/1.1
Host: jingyan.baidu.com
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:92.0) Gecko/20100101 Firefox/92.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2
Accept-Encoding: gzip, deflate, br
Referer: https://www.baidu.com/link?url=3MYyQnhUNvb0WZ6fx-iURy86qugB6-yMFGI7kouDzC46_O6c7vdGeinYRVYhXE5XVkKL6d7918xZbjfVn30lFrf_kBRYjMltPWmkjntZO4C&wd=&eqid=b33b0e350007696100000002614d2269
Connection: keep-alive
Cookie: BAIDUID=84AC2E3F08910E0A86009C5123A582A8:FG=1; BIDUPSID=E52CF02E8A85497FDCD7843CABB6C220; PSTM=1591362239; 。。。。
Upgrade-Insecure-Requests: 1
Sec-Fetch-Dest: document
Sec-Fetch-Mode: navigate
Sec-Fetch-Site: same-site
Cache-Control: max-age=0
```

1. 请求行：HTTP请求报文的第一行，包含方法字段、URL字段和HTTP版本字段

   - `GET /article/ae97a6469d2591fafd461dd4.html HTTP/1.1`

   1. 方法字段：GET/POST/HEAD/PUT/DELETE，当浏览器请求一个对象时使用GET方法
   2. URL字段：带有请求对象的标识
   3. HTTP版本字段：HTTP/1.1

2. 首部行：请求行后继行

   1. Host：指明对象所在主机
   2. User-Agent: 首部行用来指明用户代理，即向服务器发送请求的浏览器类型。(Mozilla-Firefox)
   3. Accept-Language:首部行标识用户想得到该对象的语言版本
   4. ...

#### 2-HTTP响应报文


```http
HTTP/1.1 200 OK
Bdpagetype: 3
Bdqid: 0xf275fc6200001d4c
Cache-Control: private
Ckpacknum: 2
Ckrndstr: 200001d4c
Connection: keep-alive
Content-Encoding: gzip
Content-Type: text/html;charset=utf-8
Date: Fri, 24 Sep 2021 03:07:45 GMT
Server: BWS/1.1
Set-Cookie: delPer=0; path=/; domain=.baidu.com
Set-Cookie: BD_CK_SAM=1;path=/
Set-Cookie: PSINO=2; domain=.baidu.com; path=/
Set-Cookie: BDSVRTM=41; path=/
Set-Cookie: H_PS_PSSID=34652_34530_34068_31253_34655_34584_34518_34662_34578_26350_34420_34697_34676; path=/; domain=.baidu.com
Strict-Transport-Security: max-age=172800
Traceid: 1632452865242458036217471147827290709324
Vary: Accept-Encoding
X-Frame-Options: sameorigin
X-Ua-Compatible: IE=Edge,chrome=1
Transfer-Encoding: chunked
```

1. 初始状态行：协议版本字段、状态吗字段和状态信息
2. 首部行
   1. Date:首部行指示服务器产生并发送该响应报文的日期和时间(服务器检索到该对象，将该对象插入响应报文并发送报文的时间)
   2. Server:首部行指示该报文是一台BWS/1.1服务器产生的(Baidu Web Server)
   3. Content-Length/Type：首部行指示被发送对象的字节数和文本形式
   4. ...
3. 实体体：报文的主要部分，包含了请求的对象本身

#### 3-常用状态码和相关短语

1. 200 OK:请求成功，Web 服务器成功处理了客户端的请求，信息在返回的响应报文中
2. 301 Moved Permanently: 请求的对象被永久转移，新的URL在响应报文的Location：首部行中。客户软件将自动获取新的URL
3. 302：临时重定向，浏览器会抓取重定向后网页的内容而保留旧的网址，因为搜索引擎认为重定向后的网址是暂时的。
4. 304: Not Modified 对应条件get方法 - 标识Web缓存器中的缓存为最新版本
5. 400 Bad Request：通用差错代码，指示该请求不被服务器理解，多为参数不合法导致 Web 服务器验参失败。
6. 404 Not Fount: 被请求的文档不在服务器上，Web 服务器找不到资源。
7. 500：Web 服务器错误，服务器处理客户端请求的时候发生错误。
8. 503：服务不可用，服务器停机。
9. 504：网关超时。
10. 505 HTTP Version Not Supported: 服务器不支持请求报文使用的HTTP协议版本



#### 4.版本更替

HTTP 1.0: 短连接，每次请求响应建立新的TCP连接来进行处理。

HTTP 1.1: 长连接，一个TCP连接上可传送多个HTTP请求响应，减少连接建立、关闭的消耗和延迟。 

- HTTP1.1 长连接每个请求接受响应后才能继续发起请求，浏览器从获取html页面开始对其解析、评估页面时增量获取更多资源。  （服务器处理某个请求过程一旦阻塞，则客户端后续请求资源也得等待直至接受响应）

HTTP 2.0: 长连接多路复用使得一个连接并发处理多个请求。

- HTTP2.0 获取html页面后针对其内部css、js、img等静态资源可以异步申请获取。
- 客户端同时发送多个请求，服务器及时处理请求并将响应结果回传给客户端。



WebSocket: 即时通讯协议，在单TCP连接上进行全双工通信协议。 服务端主动推送消息给客户端。

- 及时通讯的其他策略： ajax轮询-浏览器隔时间发送请求接受响应； long poll-阻塞模型，浏览器发起请求后阻塞直至接受到response。

- 握手过程基于HTTP协议
  - 请求：Upgrade: websocket；  Connection: Upgrade。发起请求使用WebSocket协议。
  - 响应：HTTP/版本 101 Switching Protocols。




### 2.2.4 用户和服务器的交互：cookie

- HTTP使用Cookie: Web站点希望能识别用户以限制用户访问或将内容与用户身份联系。

Cookie的四个组件：

1. HTTP响应报文中的一个cookie首部行
2. HTTP请求报文中的一个cookie首部行
3. 用户端系统中保留有一个cookie文件，由用户浏览器进行查看
4. 位于Web站点的一个后端数据库。

当用户首次访问一个站点时可能需要提供一个用户标识(姓名、年龄...)，后继会话中浏览器向服务器传递一个cookie首部从而向服务器标识了用户，即cookie可在无状态的HTTP之上建立一个用户会话层。



HTTP无状态协议，服务器无法从网络连接来判断客户身份。

Session：服务器使用的记录客户端状态的机制，为特定用户创建特定session以标识这个用户并跟踪用户记录用户状态。

Coookie - **小段文本信息，客户端请求服务器且服务器需记录用户状态时，可使用response向客户端浏览器发一个cookie。客户端浏览器保存该cookie，再次请求该网站时将请求网址与cookie一同提交给服务器，服务器借此辨别用户状态。**（浏览器保证cookie的不跨域性）

- 服务端识别特定用户：服务端在告诉客户端在Cookie中记录一个Session ID, 后续每次请求时将该Session ID发送给服务器； 禁用cookie - url重写sid=xxxxx以识别用户
- 记录用户账户与密码，开启cookie权限网站脚本读取信息记录到cookie中



### 2.2.6 条件GET方法

- HTTP协议提供的机制，允许缓存器证实其保存的对象是最新的而非陈旧的 （浏览器缓存客户和已访问过的网页页面）
  1. 请求报文使用GET方法
  2. 请求报文中含有一个If-Modified-Since首部行

工作机理：

1. 请求报文中首部行If-Modified-Since值等于最近一次服务器发送的相应报文中的Last-Modified:首部行的值
2. Web服务器向缓存器发送一个相应报文，包含Last-Modified信息
   - 304 Not Modified - (响应报文中实体体为空) 标识缓存器中的缓存为最新版本，可以直接使用



### 2.2.7 HTTPS

<img src="C:\Users\86137\AppData\Roaming\Typora\typora-user-images\image-20220427152817787.png" alt="image-20220427152817787" />



**HTTPS是在HTTP基础上添加了SSL/TLS安全协议构成的，相当于对HTTP添加了加密+认证+完整性保护功能**

- 加密方法

  - 获取证书：服务器需先向证书颁布机构CA申请证书，HTTPS请求时服务器会将证书发送给客户端，证书会验证服务器发布的公钥正确性。

  1. 对称加密：加密、解密方法对外公开，加密解密使用同一个私钥进行。
  2. 非对称加密：加密使用公钥对外公开，解密使用私钥

  - **HTTPS采用混合加密方式进行加密 - 对传输数据使用对称加密（数据量比较大）；对对称加密的私钥使用非对称加密（私钥数据量小）提高私钥的安全级别。**



HTTPS传输步骤

1. 客户端发送请求 Client Hello
   - 包含TLS版本，加密套件，**发送生成的第1随机数**
2. 服务器发送响应 Server Hello
   - 确认支持的TLS版本，加密套件，**发送生成的第二随机数**
3. 服务器发送证书 Certificate
4. 服务器发送非对称加密公钥 Server Key Exchange
5. 服务器发送结束 Server hello Done
6. 客户端生成**预主密钥**，使用接受的公钥加密发送 Client Key Exchange
   - 客户端使用预主密钥，第一随机数，第二随机数生成 **会话密钥**
7. 服务端使用私钥解密预主密钥
   - 服务端使用预主密钥，第一随机数，第二随机数生成会话密钥
8. 两者使用会话密钥对数据加密解密 - 对称加密



## 2.3 电子邮件SMTP

- SMTP工作流程：

  ![capture_20220105135537203](D:\Huawei Share\Screenshot\capture_20220105135537203.bmp)

三个主要组成成分:SMTP

1. 用户代理：电子邮件的客户端软件，允许用户阅读、回复、转发、保存和撰写报文
2. 邮件服务器：电子邮件体系结构的核心  代理->自己邮箱->对方邮箱->阅读
3. SMTP: 电子邮件主要应用层协议，使用TCP可靠数据传输服务，从发送方邮件服务器到接收方邮件服务器发送邮件。
   - **每台服务器既运行SMTP客户端也运行服务器端(根据发送/接受的行为不同)**
   - SMTP一般不使用中间邮件服务器发送邮件，假设用也不再中间某个邮件服务器存留。

### -  与HTTP对比

- 相同点：都用于从一台主机向另一台主机传送文件，持续的HTTP和SMTP都是用持续连接
  - HTTP: Web服务器向Web客户
  - SMTP: 从一个邮件服务器到另一个邮件服务器
- 不同点1: HTTP主要为一个**拉协议**，SMTP主要为一个**推协议**
  - 拉：用户使用HTTP从该服务器拉取想要从Web获取的信息
  - 推：发送邮件服务器把文件推向接收邮件服务器
- 不同点2：SMTP要求每个报文用7比特ASCII编码，否则必须按照;HTTP不受限制
- 不同点3：HTTP把每个对象封装到自己的HTTP响应报文中，SMTP把所有对象封装到一个报文中
- 不同点4：首部 - SMTP： FROM；TO；SUBJECT；DATA



- MIME：扩充7ASCⅡ
- POP3：从接收端邮件服务器到接收端用户代理
- IMAP：POP3的扩充，只看到首部与主题，若用户需要打开才上传到用户计算机
- 基于万维网的电子邮件:
  - 发送方用户代理->发送方服务器：HTTP
  - 发送方服务器->接收方服务器：SMTP
  - 接收方服务器->接收方用户代理：HTTP



## 2.4 DNS - 目录服务

- 主机名的两种标识方法：
  1. 主机名：www.google.com (少提供主机位置信息，且由路由器难以处理的不定长字母数字组成)
  2. IP地址：xxx.x.xxx.xx (一句点分隔0~255的十进制数字，**层次结构，从左到右逐渐具体化**，易于路由器处理)

### 2.4.1 DNS提供的服务

- **域名系统DNS：基于人们偏爱的主机名与路由器偏爱的IP地址进行折中的主机名到IP地址转换的目录服务**

  1. 一个由分层的DNS服务器实现的分布式数据库
  2. 一个使主机能查询分布式数据库的应用层协议

  - 通常运行在BIND软件的UNIX系统，运行在UDP之上使用53号端口

- **主机别名**: 为复杂主机名（规范主机名）的主机拥有一个或多个别名

- **邮件服务器别名**：MX记录允许一个公司的邮件服务器和Web服务器使用相同的主机名 - DNS解析

- **负载均衡**：DNS用于在冗余服务器之间进行负载分配



###### DNS将主机名转换为IP地址的步骤：

1. *同一台用户主机*上运行的DNS应用客户端
2. 浏览器从URL抽取出主机名，将主机名传给DNS应用的客户端
3. DNS客户向DNS服务器发送一个包含主机名的请求
4. DNS客户最终收到一份回答报文，其中含有对应该主机名的IP地址
5. 浏览器一收到来自DNS的IP地址，就能够向位于该IP地址80端口的HTTP服务器进程发起一个TCP连接

- 注：想获得的IP地址通常缓存在附近的DNS服务器中（网络流量、平均时延降低）



### 2.4.2 DNS工作机理 

#### 1. 分布式、层次数据库

- DNS使用大量DNS服务器，以层次方式组织并分布于全世界范围。

- 主要有如下三种DNS服务器：根DNS服务器、顶级域(TLD)DNS服务器、权威DNS服务器
  1. 根DNS服务器: 有13个根名字服务器遍及世界，**提供TLD服务器的IP地址**
  2. 顶级域DNS服务器：对于每个顶级域都有TLD服务器（集群）
     - 顶级域：com、org、net、edu、gov、uk、fr、jp等
  3. 权威DNS服务器: 因特网上具有公共可访问主机的每个组织机构都必须提供的公共可访问DNS记录，这些记录将这些主机名映射为IP地址。 **一个组织机构的权威DNS服务器收藏了这些DNS记录。**
- 本地DNS服务器：每个居民区或者机构ISP都有一台本地DNS服务器，当主机与某个ISP连接时，该ISP提供一台主机的IP地址，该主机具有一台或多台其本地DNS服务器的IP地址。 - 本地DNS服务器通常较近，便于直接建立连接。

###### 大致步骤：假设用户要访问主机名www.google.com的IP地址

1. 客户首先与根服务器之一联系，返回顶级域名为com的TLD服务器IP地址
2. 客户与这些TLD服务器之一联系，将为google.com返回权威服务器的IP地址
3. 客户与google.com权威服务器之一联系，为主机名www.google.com返回IP地址



#### 2. DNS缓存

- 在一个请求链中，当某DNS服务器接受一个DNS回答时，能将映射缓存在本地存储器中（一段时间后将丢弃缓存信息），下次请求的IP地址若存在与本次缓存中可直接返回该IP地址。

### 2.4.3 DNS记录和报文

- 资源记录(Resource Record - RR)：包含了如下字段的四元组（Name，Value，Type，TTL）

  - TTL：记录的生存时间，决定资源应从缓存中删除的实践

  - Name和Value取值取决于Type
    - Type=A: Name是主机名，Value是主机名对应的IP地址
    - Type=NS: Name是个域，Value是个知道如何获得该域中主机IP地址的权威DNS服务器的主机名
    - Type=CNAME: Value是别名为Name的主机对应的规范主机名
    - Type=MX: Value是别名为Name的邮件服务器的规范主机名

- DNS报文: DNS只有查询和回答报文,DNS报文格式如下:

## 2.5 P2P文件分发 - P92

P2P体系结构对总是打开的基础设施服务器有最小的(没有)依赖,**成对间歇连接的主机彼此直接通信.**





# U3-传输层

## *面试题整理*

1. TCP的三次握手与四次挥手（原理及必要性）
   1. 三次握手：防止失效连接请求报文传送到服务器产生脏连接（两次握手请求延迟）；避免死锁（两次握手响应丢失）；确认客户端与服务器段的初始序列号与确认号 （服务器端开启监听状态等待客户端请求）
   2. 四次挥手：全双工通信，发送方和接收方都需要发送FIN和ACK报文段才能断开
      - **等待2MSL(报文最大生存时间)：TCP发送最后的ACK防止ACK丢失；保证连接的所有报文从网络中消失，防止新旧连接混淆。**
   
2. TCP粘包/拆包问题 （如何发生，怎样解决）
   - 发生原因：TCP数据传输基于字节流，应用层到TCP的数据报是一连串的字节流，无边界。 UDP基于数据包传输，不会粘包。
   - 状态描述：粘包：两数据报粘连在一起无边界；拆包：一条数据报被划分边界了
   - 造成原因：
     1. 拆包: TCP发送缓冲区剩余空间不足以发送一个完整数据包
     2. 拆包：要发送数据超过了MSS（最大报文段长度）
     3. 粘包：TCP要发送数据包小于TCP缓冲区，将多个数据包写满缓冲区发送
     4. 粘包：接收端没有及时读取缓冲区数据包
   - 解决方法:
     1. 数据包首部添加长度属性指示数据包长度
     2. 给数据包添加间隔符确定边界，接收端根据间隔符区分数据包。
   
3. <u>**TCP为什么是可靠传输协议**</u>

   1. 检验和：发送方将TCP报文中所有数据以2字节为单位反码相加求和，溢出回卷，将结果赋予检验和；接收方将所有数据相加若均为1则无错误，否则有错误丢弃。

   2. 序号+确认号机制：-TCP 发送端发送数据包的时候会选择一个 seq 序列号，接收端收到数据包后会检测数据包的完整
      性，如果检测通过会响应一个 ack 确认号表示收到了数据包。

   3. 乱序重排+丢弃重复：对IP网络层到TCP数据包可能会乱序或重复，TCP会对数据包进行重新排序、去重后再发给应用层。

      - 快速重传+选择确认： 3ACK；GBN+SR

   4. 流量控制：滑动窗口- 避免发送端发送数据太快导致接收端缓冲区溢出造成数据丢失

      - 累计确认: 接收方只发送到第一个丢失报文为止的确认报文。
      - 超时重传：每发送一组报文就定时器计时，在超时后未接收到响应就重传。

      - rwnd = RvbBuffer - (LastByteRead - LastByteRcvd);
      - LastByteSend - LastByteAcked <= rwnd

   5. 拥塞控制：避免网络拥塞造成的报文丢失/超时

4. **TCP与UDP的区别:**
   1. 发送数据之前是否需要建立连接：TCP是面向连接的协议，需建立连接；UDP是无连接的。
   2. 可靠与否: TCP是可靠传输协议（无差错、不重复、按序且不丢失）；UDP不保证可靠，不会有差错，但可能重复/乱序。
   3. 工作效率：UDP实时性较好，工作效率比TCP高，适用于高速传输或实时性较高的系统。
   4. 端到端连接差异: TCP只能点到点连接，UDP可以11，1n，n1，nn
   5. 资源要求：TCP对系统资源要求较多，报文首部开销较大且需握手建立发送/接受缓冲区与变量，UDP较少
   6. TCP面向字节流，将数据看作一连串字节流，序号标识首个字节流编号，确认号标识期待接收到的对方的序号；UDP面向报文。
   7. 关于检验和: 二者都是在接收端确认发送方发送报文受否有错误；UDP-直接丢弃了(相当于丢包)；TCP-丢弃(对上一报文发送冗余ack)
   
5. TCP长连接短连接：
   - 短连接：浏览器和服务器每进行一次数据传输就建立一次连接，传输结束时终端连接。
     - 优势: 管理起来比较简单，存在的连接都是有用的连接，不需要额外的控制手段
   - 长连接：HTTP/1.1起默认方式，连接建立且读写完毕后并不会主动关闭，后续的读写过程仍会使用该链接。
     - Keep-Alive机制：给定连接2h内没有动作，将发送弹测报文段检测客户端状态，选择复位定时器/10个75s超时。
     - 服务器端可关闭一些长时间未数据传输的连接避免连接爆炸或恶意连接。
   
6. 2MSL: 保证被动关闭方能顺利关闭自己的TCP连接，释放缓冲区。

   - MSL-最大报文段存活时间

   - IP头中有一个TTL字段，表示最大路由器条数，数据报每经过一个路由器TTL-1，TTL为0时丢弃报文消亡；
   - TTL-跳数 ；MSL时间数 - MSL >= TTL减为0时所需时间，确保报文消亡
   - 2MSL：主动关闭方发送ack后接收方可能没收到，被动关闭方重发fin，一来一回<=2MSL。



- 浏览器输入URL后发生了什么 （调用过程） -   **递归+迭代**
  1. 浏览器从URL抽取出主机名，将主机名传给DNS应用的客户端
  2. 浏览器访问URL，询问本地DNS服务器是否缓存该网址解析后的IP
  3. 若本地DSN服务器未缓存，就去根服务器查询该网址对应IP地
  4. 根服务器返回顶级域服务器TLD，然后本地DNS服务器去TLD查询
  5. 顶级域服务器返回权威域服务器，本地DNS服务器去权威域服务器查询对应IP地址
  6. 本地DNS服务器拿到解析后的IP地址后缓存本地，然后把解析后的IP地址返回给浏览器



- HTTP,TCP,Socket的关系

- HTTP与TCP/IP协议关系
  1. HTTP长/短连接本质上就是TCP长/短连接
  2. HTTP属于应用层协议，TCP属于传输层协议，IP属于网络层协议
  3. IP协议主要解决网络路由和寻址问题
  4. TCP协议主要解决如何在IP层上可靠传递数据报，保证无丢失、按顺序、无差错传输。
- 跨域:
  - 一个源中的加载脚本与另一个源中的数据交互：协议、域名、端口号不同
  - 浏览器同源策略 - 限制跨域行为，不允许一个源中的加载脚本与另一个源中的数据交互。
  - 解决方案
    1. JSONP - get， datatype:jsonp
    2. CORS
    3. 代理方式



## 3.1 概述

- 运输层与应用层: 在发送端，运输层将发送应用程序进程接收到的分组转换为运输层分组(运输层报文段) -> <u>将应用报文划分为较小的块,并为每块加上一个运输层首部以生成运输层报文段.</u>
- 运输层与网络层: 网络层提供了**主机之间**的逻辑通信,而运输层为运行在**不同主机上的进程**提供了逻辑通信. 



### 3.1.2 运输层概述

- UDP/TCP - <u>多路复用与多路分解</u>: 将运行在两个端系统之间的IP交付服务扩展为运行在端系统上的两个进程之间的交付服务.
- 通过报文段首部差错检查字段提供完整性检查.
- TCP - 可靠数据传输&拥塞控制
  - 可靠数据传输: 流量控制,序号,确认号,定时器
  - 拥塞控制: 每个通过一条拥塞网络链路的链接平等的共享网络链路带宽.



## 3.2 多路复用&多路分解

引入: 一个进程有一个或多个套接字,<u>相当于从网络向进程传递数据和从进程向网络传递数据的门户</u>.



- <u>多路分解</u>:每个运输层报文段有几个字段,在接收端,运输层检查这些字段(**目的端口号字段**),标识出接受套接字,进而将报文段定向到该套接字. 
  - **运输层报文段中的数据交付到正确的套接字的工作即为多路分解**
- <u>多路复用</u>: 源主机从不同套接字接受数据块,并为每个数据块封装上首部信息(**源端口号字段**)生成报文段,将报文段传递到网络层.

![image-20211029092915519](C:\Users\86137\AppData\Roaming\Typora\typora-user-images\image-20211029092915519.png)

- 源/目的端口号:  
  - *源端口号: 用于回传报文(目的向源发送)*
  - 周知端口号: 前10比特 0~1023,保留周知应用层协议使用(HTTP,FTP)
  - 自身端口号: 1024 ~ 65535



### 1. UDP套接字

- 由包含**一个目的IP地址和一个目的端口号**的二元组标识
  - 即对一个UDP报文只需标识目的IP地址和目的端口号即可通过该套接字定向

### 2. TCP套接字

- 由一个四元组 - **源IP地址,源端口号,目的IP地址,目的端口号标识**
  - 一个TCP报文需标识四元组全部信息才可定向套接字



## 3.3 UDP - 无连接传输协议

- 无连接: 使用UDP时,**发送报文段之前,发送方和接收方的运输层实体之间没有握手.**
- UDP工作流程: <u>UDP从应用进程得到数据, 附加上用于多路复用/分解服务的源和目的端口号字段以及其他字段, 然后将形成的报文段封装到IP数据报中, 然后尽力地尝试将此报文段交付给接受主机.  若到达接受主机, UDP使用目的端口号将此报文段交付给正确的应用进程.</u>
- 举例 : DNS域名目录服务(避免TCP连接创建时延) - <u>构造DNS查询报文并交付给UDP, 主机端UDP为此报文添加首部字段然后将形成的报文段交给网络层. 网络层封装后发送给一个名字服务器. 查询主机DNS应用程序等待响应, 若无响应则向另一个服务器发送查询或通知调用程序无法响应.</u>



- 选用UDP的原因/优点 
  1. *对发送数据类型以及何时发送的应用层控制更为精细*
  2. 无须建立连接 
  3. 无连接状态 - 无序维护连接状态
  4. 分组首部开销小 - UDP仅有8字节首部开销



### 1. UDP报文段结构



### 2. UDP检验和

- 确定UDP报文段从源到目的地移动时比特是否发生改变.
  - 发送方UDP对报文段中所有16比特字的和进行反码求和 ,溢出回卷. 得到结果置于UDP报文段检验和字段.
  - 接收方将所有16比特字(包括检验和)相加,若无差错则结果全为1, 否则出错.



## 3.4 可靠数据传输原理

- 流水线可靠数据传输协议：不以停等的方式运行，允许发送方发送多个分组而无序等待确认。
  - 增加序号范围
  - 缓存多个分组
  - 处理丢失、损坏和延时过大的分组

### 1. GBN 回退N步

- 允许发送方发送多个分组不需等待确认，流水线中未确认的分组数不超过N **[base,base+N-1]**（流量窗口rwnd）
- **基序号base：最小未确认分组序号；下一个序号next：最小未使用序号**
  - **[0,base-1]已发送已确认**
  - **[base,next-1]已发送未确认**
  - **[next,base+N-1]未发送可发送**
  - **[base+N,~]不可发送**
- 分组序号模2^k运算构成环

- 超时：发送方重传所有已发送未确认分组
  - 若收到ACK仍有已发送未确认，则定时器重启；否则重启定时器
- 接收方需要唯一维护下一个按序收到的分组序号，所有冗余或者乱序都将被丢弃



### 2. SR 选择重传

- 发送方仅重传接收方出错(丢失/受损)分组，避免不必要重传
- 接收方缓存失序分组直至所有丢失分组被收到为止
  - 对应相应ack丢失的情况，接收方仍回对发送方已发送的分组序号做出相应的ack回应来让发送方窗口向前滑动



## 3.5 TCP - 面向连接的运输协议

- 面向连接: 在进程之间可以传递数据之前这两个进程必须先相互握手,建立确保数据传输的参数.



### 3.5.1 TCP概述

- TCP连接组成包括: 主机上的缓存, 变量和进程连接的套接字.
- 客户进程通过套接字传递数据流, 之后数据由客户运行的TCP控制, **TCP将数据引导至发送缓存中(握手期间建立), <u>TCP在它方便时以报文段形式发送数据</u>, TCP可从缓存中去除放入报文段的数据受限于最大报文段长度MSS(Maximum Segment Size)**
  - **MSS - 报文段中应用层数据的最大长度 (不包括首部长度)**
    - 根据最初确定的由本地发送主机发送的最大链路层帧长度(最大传输单元MTU)设置, <u>需保证一个TCP报文段加上TCP/IP首部(通常40)将适合单个链路层帧.</u>

### 3.5.2 TCP报文段结构

![image-20211029101700358](C:\Users\86137\AppData\Roaming\Typora\typora-user-images\image-20211029101700358.png)

- 源端口号,目的端口号,检验和
- 序号字段(seq - sequence number field) : **该报文段首字节的字节流编号**
  - *序号建立在传送的字节流之上而非报文段序列之上*
- 确认号字段(acknowledgement number field) : **期望接受到的下一个字节的序号**
  - **<u>累计确认: TCP只确认该流中至第一个丢失字节为止的字节</u>** 0~535 900~1033  :等待536

- 接受窗口字段(header length field) : 用于流量控制
- 首部长度字段(header length field) : 指示TCP首部长度
- 选项字段 - 可选/变长 : 发送方和接收方协商最大报文段长度/高速网络环境下用作窗口调节因子
- 标志字段: 
  - ACK: 确认字段值有效 - 对接受报文段的确认
  - RST, SYN, FIN: 连接建立与断开
  - CWE, ECE : 明确拥塞通告
  - PSH : 置位时接收方立即数据交给上层
  - URG : 指示报文段里存在被发送端上层置为紧急的数据, 以使TCP通知接收端上层实体



*序号举例: MSS为1000字节, 数据流为500000字节  (序号: 0 ~ 499)*  

**MSS:最大报文段长度，由最初确定的由本地发送主机发送的最大链路层帧长度设置**

![image-20211029104211486](C:\Users\86137\AppData\Roaming\Typora\typora-user-images\image-20211029104211486.png)

### 3.5.3 往返时间的估计与超时

- RTT: 往返时间



#### 1. 往返时间 - 活在当下

- 报文段样本RTT(SampleRTT) :  报文段被发出到该报文段的确认被收到的时间
  - 多数TCP仅在某一时刻测一次, 且只为传输一次的报文段测量
  - EstimatedRTT = (1 - α) * EstimatedRTT + α * SampleRTT - α推荐值0.125
- 偏差RTT(DevRTT) : 估算SampleRTT一般会偏离EstimatedRTT的程度
  - DevRTT = (1 - β) * DevRTT +β * |SampleRTT - EstimatedRTT| - β推荐值0.25



#### 2. 超时与重传间隔

- 超时间隔应为EstimatedRTT加上一定余量 - 余量根据DevRTT变化情况设置
  - **TimeOutInterval = EstimatedRTT + 4 * DevRTT**
  - 初始TimeOutInterval可设为1s， 超时后加倍，直到收到报文段并更新EstimatedRTT后就用上述公式



### 3.5.4 可靠数据传输

- 网络层服务IP不可靠： 不保证数据报交付、按序交付与完整性
- TCP基于IP不可靠之上创建可靠数据传输服务
  - **确保一个进程从其接收缓存中读出的数据流<u>*无损换，无间隙，非冗余且按序***</u> （与发送方数据流一致）



#### 快速重传机制

- 冗余ACK - 再次确认某个发送方先前已收到对该报文段确认的报文段的ACK
- 快速重传： **发送方一旦收到3个冗余ACK，TCP就执行快速重传 - 在<u>该报文段定时器过期之前</u>重传丢失的报文段，**
  - 发送方经常一个接一个发送大量报文段 - 若1报文段丢失会收到许多冗余ACK
  - 若TCP发送发接收到对相同数据的3个冗余ACK，其将此作为指示，说明在这已被确认3次的报文段之后的报文段已经丢失



#### 选择确认 - TCP差错恢复机制

- 选择确认 - **允许TCP接收方<u>有选择的确认失序报文段</u>，而非累计地确认最后一个正确接受的有序报文段**
  - GBN回退N步与SR选择重传的混合体



### 3.5.5 流量控制

- **流量控制服务： 消除发送发使接收方缓存溢出的可能性。**
  - 速度匹配服务，发送方发送速率与接收方应用程序读取速率相匹配。
- 实现机制: **TCP通过让发送发维护一个“接收窗口”变量来提供流量控制， <u>接受窗口用于给发送方一个指示 - 该接收方还有多少可用缓存空间</u>**
  - 接收方:
  - RcvBuffer: 接受缓存大小
  - LastByteRead: 应用进程从缓存读取的数据流最后一个字节编号
  - LastByteRcvd: 网络中到达的存入接收缓存的最后一个字节编号
  - **需满足条件： LastByteRcvd - LastByteRead <= RcvBuffer : 存储 <= 实际**
  - **接受窗口rwnd : rwnd = RcvBuffer - [LastByteRcvd - LastByteRead] ：缓存实际可用空间**
  - **接收方将rwnd值置入发给发送方的报文段接受窗口字段中，通知发送方该连接缓存剩余空间**
  - 
  - 发送方：
  - LastByteSent : 最后发送字节编号
  - LastByteAcked : 最后确认字节编号
  - **LastByteSent - LastByteAcked <= rwnd**
  - 
  - BUG:
  - 当rwnd=0时， 接收方只会读取缓存更新rwnd而不会将更新结果传给发送发 （没有接受报文了，故没有对接受报文段的ack响应了） 此时发送发不发，文件不更新
  - 解决： **当接收方rwnd=0时，发送发继续发送只有一个字节数据的报文段，这些报文段会被接收方确认。 缓存清理时确认报文中会含有更新的rwnd值**

- 区别于拥塞控制： 拥塞控制为发送方因为IP网络拥塞而被遏制
- UDP不提供流量控制 - 报文段可能由于缓存溢出而在接收方丢失



### 3.5.6 TCP连接管理

- 三次握手：
  1. **客户端TCP向服务器段TCP发送一个特殊的TCP报文段 - *SYN报文段*，该报文段不包含应用层数据（有效载荷），在报文段首部中一个标志位SYN被置为1。 客户端会随机选择一个初始序号client_isn（避免安全性攻击）将此置于该起始SYN报文段序号字段中发送给服务器。**
  2. **包含SYN报文段中IP数据报到达服务器主机后，服务器从数据报中提取出SYN报文段，为该TCP连接分配TCP缓存和变量，并向该客户TCP发送允许连接的*SYNACK报文段***（无有效载荷）  **<u>SYN置为1，确认号字段client_isn+1, 选择自己的初始序号serve-isn置入序号字段</u>**
  3. **客户收到SYNACK报文段后，给连接分配缓存和变量，客户主机向服务器发送另一个报文段，对服务器的允许连接报文段进行确认(确认号为server_isn+1), 连接建立SYN置0，可携带有效载荷。**

![image-20211029120907423](C:\Users\86137\AppData\Roaming\Typora\typora-user-images\image-20211029120907423.png)

- 四次挥手：  一条TCP连接中的<u>两个进程任何一个</u>都可以终止连接， 连接结束后主机资源（缓存，变量）被释放。
  1. **客户进程发出关闭连接命令，客户TCP向服务器进程发送一个FIN终止报文段， FIN比特被置1**
     - **客户TCP进入FIN_WAIT1，等待确认报文**
     - **收到确认报文后客户TCP进入FIN_WAIT2, 等待终止报文**
  2. **服务器接受到该报文段后，向发送方会送一个确认报文段，然后服务器发送其自身的FIN终止报文段，FIN置1**
     - **等待客户进程的ACK， 接受ACK之后不再发送，后连接关闭。**
  3. **客户对服务器终止报文段确认，发送确认ack，两主机上用于该链接所有资源被释放**
     - **发送ack后进入TIME_WAIT阶段，处理确认ack丢失时的重传。  2MSL后连接正式关闭。**    







###### 小处理 - 处理套接字/IP地址不匹配

当主机接收到一个TCP报文段，且其端口号或源IP地址与主机上的套接字都不匹配时，该主机向源发送一个特殊重置报文段，将RST标志位置1  - 通知源不要再发送该报文段



#### Question:

- q1: 两次挥手中TIME_WAIT阶段怎么知道发送的ACK丢失?

  - *30s/1min/2min取决于超时时长，在ack检测到超时未响应时就会重传，通过频繁重传来保证对方会收到ack并关闭连接。*

- q2: 若客户端服务器同时发出关闭连接申请该怎么处理？

  - 同时打开

    ![img](http://images2015.cnblogs.com/blog/740952/201611/740952-20161107133303264-146495245.png)

  - 同时关闭

    ![img](http://images2015.cnblogs.com/blog/740952/201611/740952-20161107133307483-1961364822.png)

- q3: 可否拒绝关闭响应？



### 3.5.7 TCP拥塞控制

- 量词“跳”：*由源到目的地所经历的路由器跳转次数。*



- 区别于流量控制：
  - 流量控制： 消除发送发使接收方缓存溢出的可能性。
  - 拥塞控制： 避免网络拥塞且保证充分利用可用带宽。



- 拥塞原因与代价：
  1. 发送速率接近链路容量：分组的到达速率接近链路容量时，分组将经历巨大的排队时沿。
  2. 重传丢失占用带宽：发送方必须执行重传来补偿因缓存溢出而丢失的分组。 - 占用链路带宽
  3. 多跳路由中后跳丢失危害：当一个分组沿一条路径被丢弃时，每个上游路由器用于转发该分组到丢弃该分组的使用传输容量被浪费。

- 拥塞控制方法：
  1. **端到端拥塞控制: TCP使用此方法（IP层不会向端系统提供有关网络拥塞的反馈信息）**
  2. 网路辅助的拥塞控制:  - 路由器向放松放提供关于网络中拥塞状态的显式反馈信息
     1. 直接网络反馈 - 路由器向发送方反馈 
     2. 经由接收方的网络反馈 - 路由器标记或更新分组某些字段指示拥塞产生。



- **TCP拥塞控制**

  - 采用方法：端到端拥塞控制，让每一个发送方根据所感知的网络拥塞程度来限制其能向连接发送流量的速率。
    - 限制方法：运行在发送方的TCP拥塞控制机制跟踪一个变量- **拥塞窗口cwnd** （rwnd接受窗口 - 流量控制）
    - 发送方：LastByteSend - LastByteAcked <= min{cwnd, rwnd}
    - TCP自计时：TCP使用确认Ack来触发增大其拥塞窗口长度。

  - TCP拥塞控制算法： （忽略慢启动 - 很快）**加性增，乘性减拥塞控制方式 AIMD**

    1. **慢启动：cwnd的值以一个mss （最大报文段长度）开始且每当传输报文被<u>首次确认</u>就增大一倍mss**

       - 首次结束：cwnd出现一个超时指示丢包（即拥塞）时将cwnd置1并将ssthresh置为超时状态cwnd/2
  - 再次结束：cwnd翻倍到ssthresh时停止慢启动，进入拥塞避免

  2. **拥塞避免：每轮RTT（往返时沿）只将cwnd的值增加一个mss**

     - 超时丢包：=慢启动首次结束相同
     - 3ack丢包：（3个冗余ack），ssthresh = (cwnd+3)/2，进入快速恢复

  3. **快速恢复（不必须）：保持cwnd，对丢失报文段的ack到达时，TCP降低cwnd后进入拥塞控制。**

     - 超时丢包：= 慢启动首次结束

     

    - TCP Tahoe： 慢启动+拥塞避免
  - TCP Reno：   三者结合

  - TCP吞吐量描述： w表示窗口长度，RTT表示往返时沿 **则传输速率在w/(2*rtt) ~ w/rtt之间变化**

- **TCP吞吐量：0.75*w/RTT**

  - 公平性：K条连接共享Rbps瓶颈链路 -> 每条连接平均传输速率接近R/k
    - UDP不施行拥塞控制，可能占用链路挤压TCP
    - 多TCP连接时带宽比例较大





# U4-网络层 数据平面

- 网络层职责: 将分组从源主机传送至目的主机，为网络上的主机提供通信服务。



- 网络中每台主机与路由器均有的一个网络层部分，可被分解为两个相互作用的部分：**数据平面和控制平面**
  - 数据平面：由路由器的输入链路向其输出链路转发数据报。
    - 转发：将路由器输入链路的分组转发到其适当的输出链路 - *转发表*
  - 控制平面：协调这些本地的每路由转发动作，使得数据报沿着源和目的地主机之间的路由器路径最终进行端到端传送。
    - 路由选择：确定从源到目的地的端到端路径 - *路由选择算法*



## 4.1 路由器工作原理



<img src="C:\Users\86137\AppData\Roaming\Typora\typora-user-images\image-20211127094955724.png" alt="image-20211127094955724" style="zoom: 67%;" />

1. 输入端口：
   1. 终结入物理链路的物理层功能
   2. 与入链路远端的数据链路层交互来执行数据链路层功能
   3. **执行查找功能，查询转发表决定路由器的输出端口**
2. 交换结构：**将路由器的输入端口连接到它的输出端口**
3. 输出端口：存储从交换结构接收到的分组，执行必要的链路层、物理层功能在输出链路上传输这些分组。
4. 路由选择处理器：执行控制平面功能，维护路由选择表与关联链路状态信息，为该路由器计算转发表。



- **转发实现：最长前缀匹配规则** - 路由器使用分组目的地址的前缀与转发表中的表项进行匹配；若只存在一个匹配项则向该匹配项相关联的链路转发分组；<u>若有多个匹配项则使用最长前缀匹配规则-在表中寻找最长的匹配项相关联链路转发。</u>

- 交换：通过交换结构，分组从一个输入端口转发到一个输出端口

  1. 内存交换：由CPU(路由选择处理器)直接控制下完成
  2. 总线交换：经一根共享总线将分组传送到输出端口
  3. 纵横式交换：复杂互联网络M*N交换

- 输出端口：处理取出已经存放在输出端口内存中的分组并将其发送到输出链路

- 排队现象的发生：

  - **丢包: 在一台路由器的输入/输出队列中某些分组被实际丢弃/丢失。**

  1. 输入排队：*交换结构不能使所有分组无时沿地通过它进行传送。*  
     - **线路前部阻塞(HOL阻塞)** : 一个输入队列中排队的分组必须等待通过交换结构发送（即使它对应的输出端口是空闲的但它前面FCFS的分组可能被阻塞）。
  2. 输出排队 :  分组到达输出端口的速率>输出端口传输分组的速率
     - 处理策略(主动队列管理算法AQM)：缓存填满之前就丢弃一个分组，向发送发提供拥塞信号。

- 分组调度：处理排队分组经输出链路传输

  1. FIFO/FCFS
  2. 优先权排队：到达输出链路的分组被分类放入输出队列中的优先权类。（高低优先权队列）
  3. 循环公平排队：分类但不分严格服务优先权，循环调度器在类间轮流提供服务。
  4. *加权公平排队：*





## 4.3 IPV4、寻址、IPv6

- IPv4数据报格式

  <img src="C:\Users\86137\AppData\Roaming\Typora\typora-user-images\image-20211127104241564.png" alt="image-20211127104241564" style="zoom:67%;" />
  
  - 版本号：根据版本号路由器选择解析IP数据报剩余部分
  - 首部长度：确定IP数据报中载荷实际开始地方（大部分不包含，一般20字节首部）
  - 服务类型：区分服务类型，使不同类型IP数据报(低时延、高吞吐量)能相互区分。
  - 数据包长度：IP数据报总长度 - 字节
  - **标识、标志、片偏移：与IP分片有关**
  - **寿命Time-To-Live TTL: 数据报每经过一台路由器TTL-1 确保数据报不会再网络中永远循环。**
  - 协议：指明IP数据报载荷应交付于特定的运输层协议 6-TPC; 17-UDP
  - **首部检验和：检测收到的IP数据报比特错误 （每两字节为一个数字反码求和）**
    - TCP/UDP运行在不同协议栈，IP能携带不一定传送给TCP/UDP的数据
  - 源/目的IP地址 32位：（通过DNS查找目的地址）
  - 选项：允许IP首部被扩展



- 数据报分片： **每个IP数据报被封装在链路层帧中从一台路由器传输到下一台路由器，一个链路层帧能承载的最大数据量(MTU)严格限制IP数据报的长度。**
  - **分片：将较大的IP数据报分片成两个或多个较小的IP数据报，用单独的链路层帧封装这些较小的IP数据报，通过输出链路发送帧。**
  - **组装地点：将数据报重新组装工作放在端系统中而非网络路由器中。**
  - **拆分流程：利用标识、标志、片偏移字段**
    - <u>标识：生成数据报时，发送主机生成源、目的IP地址的同时贴上标识号，将每个数据报的标识号加1.</u>
    - <u>标志：路由器分片时，形成的每个片具有初始数据报的源、目的地址和标识号(相同数据报分出的片具有相同标识号)，最后一片的标志被设置为0表时收到最后片，其余为1</u>
    - <u>片偏移：指定该片在初始IP数据报的哪个位置 - 确定是否丢失一个片</u>



- IPv4编址：

  - **接口：主机/路由器与物理链路之间的边界** （主机只有一个，路由器有>=2个）；每台主机和路由器接口都必须有自己的IP地址 （二者均可发送/接受IP数据报）

  - 地址标识方法-**点分十进制记法**：每8个比特的十进制等价数用.隔开

  - 子网：互联<u>(主机接口与路由器接口)/(路由器之间接口)</u>形成的网络

    - 子网掩码：X.X.X.X/Y : 32比特的IP地址中前Y比特定义的子网地址。 

  - 因特网地址分配策略 : <u>**无类别域间路由选择CIDR**</u>

    - **一个组织被分配一块连续的地址（共同的前Y比特），该组织内部的IP地址共享共同的前缀；剩余的32-Y比特用于区分该组织内部设备。**
    - 广播地址255.255.255.255 - 当一台主机发出目的地址为广播地址的数据报时，该报文会交付给同一个网络中的所有主机。路由器也会<u>有选择地</u>向临近的子网转发该报文。

    1. 组织获取一块地址：由ICANN管理分配IP地址
    2. 获取主机地址：管理员手工配置/动态主机配置协议DHCP （CS协议 DHCP服务器/中继代理）
       - DHCP允许主机自动获取（被分配）一个IP地址，*可通过网络管理员配置使给定主机每次联网时获得相同IP地址。*
       - yiaddr: 你的ip地址
       - <img src="C:\Users\86137\AppData\Roaming\Typora\typora-user-images\image-20211127115319909.png" alt="image-20211127115319909" style="zoom:67%;" />

  

- 网络地址转换NAT - NAT使能路由器对外界隐藏了其家庭网络的细节，*其对外界的行为像是一个具有单一IP地址的单一设备。*

  - 使用场景：已分配一固定连续地址范围但子网变大需更大的地址。
  
  - <u>通过端口号转换(端口号为16比特长)，主机发送请求时在ip地址后指派了任意一个源端口号，将该请求发送到NAT中，NAT从NAT转换表中选取未使用过的端口号加上其IP地址作为源地址发送出去，并在NAT转换表中新添加一项端口转换记录；NAT接收到响应报文，根据其目的端口号从NAT转换表中选取合适的目的主机端口号与IP地址发送给目的主机。</u>
  - WAN端口主要是接入外网，让一定区域内的设备有访问外网的来源。
    
  - LAN端口主要是把外网和上网设备进行连接的端口，这样设备就可以进行访问外网的操作。





- IPv6: 解决IP地址不够用的情况
  - 区别于IPv4：地址空间128位；不支持路由器上分片(较大则丢弃并向发送方返回差错报文请求较小分片)
  - 转换方法：建隧道 - 借助于隧道在发送端IPv6数据报封装到IPv4数据报有效载荷中，发送到指向IPv6数据报接收端节点，接收端从IPv4中取出IPv6数据报再为其提供路由。



- 网际控制ICMP报文：

  - ICMP差错报文：

    - 结构：**IP数据报的首部+8个字节组成数据字段，添加首部构成IP数据报**

    ![capture_20211231172641266](D:\Huawei Share\Screenshot\capture_20211231172641266.bmp)

    1. 终点不可达：不可向上交付数据报
    2. TTL报文：路由器收到TTL=0时发送时间超过报文；终点没有收到完整数据报时旧丢弃并发送
    3. 参数问题：首部字段不正确
    4. 改变路由（重定向）报文：选择合适路径

  - ICMP探寻报文：

    1. 回送/回答报文：ping探测目的是否可达
    2. 时间戳请求回答：时钟同步&时间测量

  - 应用：ping & Traceroute (根据TTL机制)



# U5-网络层 控制平面

- 转发表和流表在路由器中的维护、安装方式
  1. 每路由器控制-传统方法：路由器间进行路由选择算法通信，计算出路由器的转发表。
  2. 逻辑集中式控制-SDN方法：路由器仅执行转发功能，由远程控制器计算并分发转发表。
     - 控制器与每条路由器中的控制代理CA通信交互以配置、管理路由器的转发表。





## 5.2 路由选择算法

- 目的：从发送方到接收方确定一条通过路由器网络的良好路径。（最低开销）

 

分类依据1：根据算法集中/分布

1. 集中式路由选择算法：用完整性、全局性网络知识计算出从源到目的地之间的最低开销路径。（具有连通性和链路开销的完整性信息 - 链路状态算法LS）
2. 分散式路由选择算法：路由器以迭代、分布的方式计算出最低开销路径。（没有节点拥有链路开销的完整性信息） - 距离向量DV算 法。 



分类依据2：根据算法静态/动态

1. 静态路由选择算法：路由随时间变化缓慢 - 人工调整链路开销。
2. 动态路由选择算法：随着网络流量负载/拓扑变化而改变路由选择路径。



分类依据3：负载敏感/迟钝

1. 负载敏感算法：链路开销动态变化以反映底层链路拥塞水平
2. 负载迟钝算法：链路开销不明确地反映当前拥塞水平。



### 5.2.1 链路状态路由选择算法LS

![image-20211231175550051](C:\Users\86137\AppData\Roaming\Typora\typora-user-images\image-20211231175550051.png)

- 基于所有网络拓扑和链路开销已知 - 将其作为LS的输入。
  - 通过*链路状态广播算法 - 让每个节点向网络中所有其他节点广播链路状态分组。*



### 5.2.2 距离向量路由选择算法DV

- RIP协议：通过UDP数据报传输

![image-20211231174149109](C:\Users\86137\AppData\Roaming\Typora\typora-user-images\image-20211231174149109.png)

- DV - 迭代（此过程一直持续到邻居之间无更多信息要交换）；分布式（每个节点都要从一个/多个直接相邻节点获取信息）；异步（不要求所有节点相互之间步伐一致）

- Bellman-Ford方程： $\d_x$

- 运行步骤：

  1. 对于x的每个邻居v，计算从x到直接邻居v的开销c(x, v)
  2. 节点x的距离向量D_x，包含x到N中所有目的地的开销估计值
  3. 它的每个邻居的距离向量D_v

  - **每个节点不时向其邻居节点发送其距离向量副本，邻居节点保存该距离向量然后使用Bellman方程更新其自己的距离向量**



- 链路开销转变&链路故障
  1. 链路开销降低，传播较为迅速
  2. 链路开销增加时可能会造成**路由选择环路** - 为到达x，y通过z，z又通过了y
- 处理策略：毒性逆转 - 若z通过y到达x，则z将通知y（z到x的距离无限大），此时y将不再试图经由z到达x



![capture_20211231210942235](D:\Huawei Share\Screenshot\capture_20211231210942235.bmp)

## 5.3 OSPF - 自治系统内部路由选择

- 自治系统必要性：**路由器规模+ISP管理自治**

- AS自治系统：一组在相同管理控制下的路由器组成*(一个ISP中的路由器和互联他们的链路构成)*，相同的AS中路由器都运行相同的路由选择算法（**自治系统内部路由选择协议**）且有彼此的信息。
- 自治系统由全局唯一AS号(ASN)所标识。
- OSPF - 广泛用于AS内部路由选择，链路状态协议。
  - 路由器向自治系统内所有其他路由器广播其路由选择信息。



## 5.4 BGP(边界网关协议) - 自治系统间路由选择协议

-  分组：路由到CIDR化的前缀 - 标识一个子网或子网集合
  - 路由器转发表形式：(x，I)   x-前缀；I-路由器接口之一接口号
- BGP主要做法：
  1. **从邻居AS获得前缀的可达性信息**
  2. **确定到该前缀的最佳路由**



- AS结构：**每台路由器使用179端口的半永久TCP连接交换路由选择信息。**
  - 网关路由器: 位于AS边缘的路由器，直接连接在其他AS中的一台或多台路由器
  - 内部路由器：AS内部路由器
  - 外部BGP(eBGP): 跨越AS间的BGP连接
  - 内部BGP(iBGP): 相同AS中的路由器间BGP会话



### 确定路由

- 路由：前缀与BGP属性
  - BGP属性 AS-PATH:包含通告已经通过的AS列表，**通过AS时AS将其ASN加入AS-PATH中**，可避免环路
  - BGP属性 NEXT-HOT: AS-PATH起始的路由器接口的IP地址



- 热土豆路由选择：对于一台路由器，仅可能块地将分组送出其AS，不顾及AS外部到目的地余下部分的开销。（烫手山芋）
- 路由器选择算法：**对于任何给定目的地前缀，进入BGP的路由选择算法的输入为其到某前缀的所有路由集合。如下顺序消除直至仅剩余一条路由**
  1. 路由被指派一个**本地偏好值**作为其属性之一 ：策略决定，取决于AS网络管理员
  2. 从余下路由中选择具有最短AS-PATH路由(唯一规则时 - 距离向量，距离测度为AS跳的跳数)
  3.  余下路由中使用热土豆路由选择（选择最靠近NEXT-HOP路由器的路由）
  4. 使用BGP标识符来选择路由。 



### AS间与AS内部差别

1. 策略：AS间策略问题起主导作用（确定一个AS流量能否穿过另一个特定AS）
2. 规模：扩展一个路由选择算法及其数据结构以处理到大量网络(之间)的路由选择能力。
3. 性能：AS间面向策略路由选择，路由知量(性能)较为次要。 -路由选择算法1-本地偏好值



# U6 - 数据链路层

## 6.1 概述

- **节点：运行链路层协议的任何设备**
- **链路：沿着通信路径连接相邻节点的通信信道**
  - 广播信道：有线局域网
  - 点对点通信链路：
- 功能：在物理层基础上向网络层提供服务，将数据报可靠传输到相邻目标节点的网络层，**加强物理层传输原始比特流的功能**。
  - 成帧：将网络层数据报用链路层帧封装
  - 链路接入：MAC协议规定帧在链路上的传输规则
  - 可靠交付：多为本地修复 - 不确认
  - 差错检测纠正：发送节点在帧中包括差错检测比特，让接受节点进行差错检查。
- 实现地点: 网络适配器（网络接口卡），核心是链路层控制器 - 专用芯片实现了成帧、链路接入、差错检测等功能。



## 6.2 差错检测&纠正

- 发送方发送 **EDC-差错检测和纠正比特** 来增强 **数据D**

1. 奇偶校验：奇校验/偶校验 - 补充位使得所有比特中1的个数为奇/偶
   - 二维奇偶校验：将比特位按行、列划分，对每行每列进行奇偶校验
2. 检验和方法：与TCP/UDP相同，但在适配器中使用硬件实现
3. <u>循环冗余检测CRC：</u>
   - **生成多项式G：发送方与接收方协商的r+1比特模式 最高位为1**
   - **发送方附r个比特R：D * 2^r XOR R**
   - **接收方d+r比特能被G整除D * 2^r XOR R = nG - 否则差错**
     - D * 2^r = nG XOR R  -> D * 2^r / G = n ...... R



## 6.3 多路访问链路和协议

- **多路访问协议: 节点通过协议来规范其在共享广播信道上的传输行为**
  - 碰撞：所有节点都可能传输帧 - 同一节点同时接收到多个帧 - 帧失效
- 协议所希望的特性：R - R/M - 分散 - 简单



### 1. 信道划分协议

- TDM时分复用 or FDM频分复用
- TDM：将时间划分为时间帧，每个时间帧分配N个时间隙用于给N个节点传输分组（时间隙应满足节点能传输一个分组）
- FDM：将Rbps信道划分为N个频段，每个分配R/N带宽



### 2. 随机接入协议

- 纯ALOHA：传输节点总是以全部速率进行发送，发生碰撞时每个碰撞节点反复重发其帧直至无碰撞通过
  - 节点经历碰撞后选择一个随机等待时沿而非立刻转发
- 时隙ALHOA：划分时隙，节点同步，帧只能在每个时隙开始点发送



### 3. 轮流协议

- 轮询协议：选择主节点，主节点以循环方式轮询每个节点并通知能传输的帧的最多数量
  - 主节点通过观察在信道上是否缺乏信号来决定某个节点何时完成帧的发送。
- 令牌传递协议：**令牌帧**在节点之间以某种<u>固定</u>次序进行交换，当节点接收到令牌帧时，仅当其有帧要发送时才保持该令牌真，否则沿着顺序传递该令牌帧





## 6.4 交换局域网



### 1. 链路层寻址&ARP

1. MAC地址：网络接口所具有的链路层地址 - 固定公司前24比特，公司自行决定后24比特； 扁平不变化
   - 适配器发送帧 - 标准帧：匹配则接受 / 广播帧全1：全部接受
2. **ARP地址解析协议：转换IP地址与MAC地址**
   - 源和目的主机处于相同子网，此时若发送数据报不仅要向适配器提供IP数据报还要提供目的主机的MAC地址。
   - ARP转换表 - <u>存在于每台主机/路由器</u> 将IP地址转换为目的地址 + 广播存储
     - 每台主机/路由器在内存中具有ARP表：IP-MAC-TTL(从表删除某个映射的时间)
     - 转换表存在目的IP-MAC对应项 - 直接发送
     - **转换表不存在 - 构造ARP分组包含源、目的IP、MAC地址(目的MAC地址为广播地址)，封装于帧中广播发送；对于每个接受节点，将该帧中ARP分组向上传递给ARP模块，ARP模块检查IP地址是否匹配，若匹配则返回响应ARP分组，封装于帧中回传。** 此后发送方在自己的ARP转换表项中增加这个响应ARP分组的MAC地址与对应IP地址匹配项。
     - 网络间传递：主机->路由器->网络层转发->目的局域网->目的主机



### 2. 以太网

- 以太网帧：将物理层比特流分组，一组比特流即为一个数据链路层帧
  - Ethernet以太网协议：数据帧分为报头head与数据data两部分
  - head：源地址6+目的地址6+数据类型2(联系上层协议)+CRC4+前同步码8
  - data: MTU数据部分 46~1500字节   填充去除/分片
- 以太网帧既不否定也不确认 - 出错即丢弃



### 3. 链路层交换机

链路层交换机：（不含有MAC地址）交换链路层帧；使用链路层地址而非IP地址转发链路层帧。

- 在主机与路由器之间透明地交换帧

- MAC地址 - 接口 - 存储时间
- 转发&过滤：假设帧从x接口到来，目的MAC地址为m1
  1. 过滤: 若表中目的MAC地址关联接口为x，丢弃。
  2. 转发: 若表中有m1对应接口，将改帧转发到改接口；否则向除x接口外广播该帧
- 自学习：
  1. 初始为空
  2. **对于每个接口接收到的入帧，记录源MAC地址与到达接口与当前时间**
  3. 一段时间(老化期)后交换机没有接收到以该地址为源地址的帧则删除该地址
- 性质：
  1. 消除碰撞：交换机缓存帧且不会在同一链路上同时传输多于一个帧
  2. 即插即用：自学习
  3. 隔离链路



